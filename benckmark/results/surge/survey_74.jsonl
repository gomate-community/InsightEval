{"id": "a08af25e-5d31-4208-aa5a-4800589c0307", "title": "Logic Locking: A Brief Overview", "level": "subsection", "subsections": [], "parent_id": "4af06642-e7a5-4612-b225-f1cae2b32e2a", "prefix_titles": [["title", "Logic Locking at the Frontiers of Machine Learning: A Survey on Developments and Opportunities"], ["section", "Introduction"], ["subsection", "Logic Locking: A Brief Overview"]], "content": "Logic locking performs design manipulations by binding the correct functionality of a hardware design to a secret key that is only known to the legitimate IP owner. Hereby, both the original functionality and the structure of the design remain concealed while passing through the hands of external design houses and the foundry. In the past decade, various security aspects of logic locking have been thoroughly evaluated through the introduction of key-recovery attacks~, among which the Boolean satisfiability (SAT) attack has gained a lot of attention~. This has led to a division of logic locking into \\textit{pre- and post-SAT schemes}. Pre-SAT schemes were focusing on specific security features, such as random XOR/XNOR key-gate insertion~, thwarting the path-sensitization attack~ or maximizing output corruption for incorrect keys~. With the introduction of SAT-based attacks, the design objective has shifted towards achieving SAT-resilience, resulting in a new generation of schemes, including SARLock~, Anti-SAT~, CASLock~, SFLL~, and others~.", "cites": [8606], "cite_extract_rate": 0.1, "origin_cites_number": 10, "insight_result": {"type": "descriptive", "scores": {"synthesis": 2.5, "critical": 2.0, "abstraction": 2.0}, "insight_level": "low", "analysis": "The section provides a basic description of logic locking and its evolution in response to SAT-based attacks, mentioning several schemes. However, it lacks synthesis of the cited works into a deeper narrative and does not offer critical evaluation or abstraction into broader principles. It functions more as a summary of developments rather than an insightful analysis."}}
{"id": "54ad821b-9b66-4cd9-b802-b507cf6fc674", "title": "The Advent of Machine Learning", "level": "subsection", "subsections": [], "parent_id": "4af06642-e7a5-4612-b225-f1cae2b32e2a", "prefix_titles": [["title", "Logic Locking at the Frontiers of Machine Learning: A Survey on Developments and Opportunities"], ["section", "Introduction"], ["subsection", "The Advent of Machine Learning"]], "content": "With the advent of efficient and easy-to-use Machine Learning (ML) models, ML-based techniques have been gradually introduced into various hardware-security domains~. The latest efforts in the logic locking community have been invested in challenging the security properties of locking schemes using ML. Recent works were able to efficiently attack pre- and post-SAT schemes~. {The introduction of ML-based tools for the security analysis of logic locking \\textit{has opened up a new chapter} in the design of locking schemes and attacks, thereby initiating the start of the \\textit{post-ML} locking-scheme era. Herewith, the ML ecosystem offers a novel path to uncover hidden vulnerabilities and provide new directions in the development of future ML-resilient locking schemes.\n\t\t\\textbf{Contributions}\n\t\tThe ML era has undoubtedly initiated a new stage in logic locking design and evaluation. In this paper, we review all major developments in the domain of \\textit{ML-based attacks and countermeasures in logic locking}, and analyze major challenges and research opportunities. Note that a comprehensive overview of the state of pre-ML schemes and attacks can be found in~.\n\t\tThe rest of this paper is organized as follows. Section~\\ref{sec:background} introduces the relevant background on logic locking. Section~\\ref{sec:ll-in-ml-era} reviews the major developments in ML-based logic locking attacks and compiles a summary of the open challenges and opportunities. Finally, Section~\\ref{sec:conclusion} concludes the paper.", "cites": [8606, 7636], "cite_extract_rate": 0.125, "origin_cites_number": 16, "insight_result": {"type": "analytical", "scores": {"synthesis": 3.5, "critical": 3.0, "abstraction": 3.5}, "insight_level": "medium", "analysis": "The section synthesizes the cited works to present a narrative about the transition from traditional SAT-based attacks to ML-based approaches in logic locking. It identifies the broader shift to a 'post-ML' era and highlights the implications of ML tools for uncovering vulnerabilities, showing some abstraction. However, it lacks deeper critical analysis of the cited works and does not systematically compare or contrast different ML-based methods, limiting its insight quality to a medium level."}}
{"id": "50b37d47-0116-40d6-afbd-43bf9dacb32b", "title": "Oracle-Less Attacks", "level": "subsubsection", "subsections": [], "parent_id": "8a41fbf8-901a-45b8-9e50-9a86985de29d", "prefix_titles": [["title", "Logic Locking at the Frontiers of Machine Learning: A Survey on Developments and Opportunities"], ["section", "Logic Locking in the Machine Learning Era"], ["subsection", "ML-Based Attacks"], ["subsubsection", "Oracle-Less Attacks"]], "content": "ML-based attacks in this class have exploited \\textit{scheme-related structural residue} to identify a correct key-bit value or the locking circuitry itself. This category includes SAIL~, SnapShot~, and GNNUnlock~.\n\t\t\\textbf{SAIL:} This attack deploys ML algorithms to retrieve local logic structures from the post-resynthesis target netlist to predict the correct key values (Fig.~\\ref{fig:attack-visualization}~(a)). The attack targets XOR/XNOR-based logic locking exclusively. Hereby, the attack exploits two leakage points of the locking flow: ($i$) the deterministic structural changes induced by logic synthesis around the key-affected netlist gates and ($ii$) the nature of XOR/XNOR-based locking (XOR for key bit 0 and XNOR for key bit 1). Therefore, the attack encloses two components: the Change Prediction Model (CPM) and the Reconstruction Model (RM). For each netlist subgraph around a key input (known as \\textit{locality}), CPM is trained to predict whether a synthesis-induced change has occurred. If a change is predicted, RM is deployed to reconstruct the pre-resynthesis netlist structures, i.e., it reverses the effect of the synthesis process. Finally, based on the intrinsic nature of XOR/XNOR-based locking, SAIL extracts the correct key value.\n\t\t\\textbf{SnapShot:} The attack utilizes a neuroevolutionary approach to automatically design suitable neural networks to \\textit{directly} predict correct key values from a locked post-resynthesis target netlist (Fig.~\\ref{fig:attack-visualization}~(b)). The attack exploits the structural alterations induced by locking schemes to learn a correlation between the key-induced structural patterns and the key value. Compared to SAIL, SnapShot implements an end-to-end ML approach, thereby having the advantage of being applicable to any locking scheme as well as not relying on learning specific transformation rules of the logic synthesis process.\n\t\t\\textbf{GNNUnlock:} The attack leverages a graph neural network to identify all the gates in a post-resynthesis target netlist that belong to the locking circuitry (Fig.~\\ref{fig:attack-visualization}~(c)). Therefore, compared to SAIL and SnapShot, GNNUnlock learns to differentiate locking gates from regular gates instead of learning a correlation between the netlist sub-graphs and the correct key. To enhance the removal accuracy, after identification, a deterministic post-processing mechanism is deployed to remove the gates depending on the intrinsic features of the underlying schemes. Hereby, GNNUnlock has specifically been trained and deployed to target SAT-attack-resilient schemes, i.e., Provably Secure Logic Locking (PSLL). Herein lies the success of the attack: PSLLs often induce isolable structural netlist changes to produce a specific SAT-resilient circuit behavior. In the pre-ML era, it has been long assumed that PSLLs can be protected through additional locking and resynthesis.\n\t\t\\begin{table}[b]\\footnotesize\n\t\t\t\\centering\n\t\t\t\\vspace{-0.2in}\n\t\t\t\\caption{Glossary}\n\t\t\t\\label{table:glossary}\n\t\t\t\\resizebox{\\columnwidth}{!}{\n\t\t\t\t\\begin{tabular}\n\t\t\t\t\t{l|l||l|l}\n\t\t\t\t\t\\toprule\n\t\t\t\t\t\\textbf{Acronym} & \\textbf{Definition}&\\textbf{Acronym} & \\textbf{Definition}\\\\\n\t\t\t\t\t\\midrule\n\t\t\t\t\t\\midrule\n\t\t\t\t\tAND-OR & AND/OR-based LL~ & LUT & Lookup table \\\\\n\t\t\t\t\tAnti-SAT & Anti-Boolean satisfiability~ & MLP & Multi-layer perceptron\\\\\n\t\t\t\t\tC & Combinational circuits & MPNN & Message-passing neural network\\\\\n\t\t\t\t\tCNN & Convolutional neural network  & OG & Oracle-guided attack\\\\\n\t\t\t\t\tCS & Logic-cone-size-based LL~ & OL & Oracle-less attack\\\\\n\t\t\t\t\tD-RNN & Deep recurrent neural network & OLL & Optimal LL~\\\\\n\t\t\t\t\tFLL & Fault analysis-based LL~ & PSO & Particle swarm optimization\\\\\n\t\t\t\t\tFU & Functional &  RLL & Random LL~\\\\\n\t\t\t\t\tGA & Genetic algorithm  & S & Sequential circuits\\\\\n\t\t\t\t\tGL & Gate level & SFLL-HD & Stripped functionality LL~\\\\\n\t\t\t\t\tGNN & Graph neural network & SLL & Strong (secure) LL~\\\\\n\t\t\t\t\tLL & Logic locking  & ST & Structural\\\\\n\t\t\t\t\tLSTM & Long short-term memory  &  TTLock & Tenacious and traceless LL~\\\\\n\t\t\t\t\t\\bottomrule\n\t\t\t\t\t\\bottomrule\n\t\t\t\t\\end{tabular}\n\t\t\t}\n\t\t\\end{table}\n\t\t\\begin{table*}[hbtp]\\footnotesize\n\t\t\t\\setlength{\\tabcolsep}{2pt}\n\t\t\t\\caption{Overview of ML-Based Attacks on Logic Locking}\n\t\t\t\\label{table:attacks}\n\t\t\t\\resizebox{\\textwidth}{!}{\n\t\t\t\t\\begin{threeparttable}\n\t\t\t\t\t\\centering\n\t\t\t\t\t\\begin{tabular}{l||>{\\centering\\arraybackslash}m{1.3cm}>{\\centering\\arraybackslash}m{0.5cm}>{\\centering\\arraybackslash}m{1.7cm}>{\\centering\\arraybackslash}m{1.2cm}>{\\centering}m{1.7cm}>{\\centering\\arraybackslash}m{1.2cm}>{\\centering}m{1cm}>{\\centering}m{1.2cm}>{\\centering\\arraybackslash}m{2.1cm}>{\\centering\\arraybackslash}m{1.7cm}>{\\centering\\arraybackslash}m{1.5cm}>{\\centering\\arraybackslash}m{1.7cm}}\n\t\t\t\t\t\t\\toprule\n\t\t\t\t\t\t\\textbf{Attack}& \\textbf{Objective}&\\textbf{Class}& \\textbf{Level/IC Type/Attack Basis}&\\textbf{ML Model}&\\textbf{Benchmarks}\\textsuperscript{16}&\\textbf{Evaluated Schemes}&\\textbf{Scheme Independent}&\\textbf{Exact Output}\\textsuperscript{15}&\\textbf{Evaluate Key Length in Bits}&\\textbf{\\% Accuracy [min, max]}&\\textbf{Time Complexity\\textsuperscript{17}}&\\textbf{Known Protection}\\\\\n\t\t\t\t\t\t\\midrule\n\t\t\t\t\t\tSAIL~& key retrieval & OL&GL/C,S\\textsuperscript{1}/ST&Random Forest& ISCAS'85&RLL, SLL, CS& \\xmark&\\xmark&$\\{4,\\cdots,192\\}$\\textsuperscript{4}&$[66.89, 73.88]$&$\\bigO(l)$\\textsuperscript{13}& UNSAIL~, SARO~\\textsuperscript{22}\\\\\\hline\n\t\t\t\t\t\tSnapShot~& ($i$) GSS and ($ii$) SRS key retrieval\\textsuperscript{14}& OL&GL/C,S/ST&MLP, CNN, GA& ISCAS'85, ITC'99, Ariane RV&RLL& \\cmark&\\xmark&$\\{64\\}$&$[57.71, 61.56]^{(i)}$, $[71.57, 81.67]^{(ii)}$&$\\bigO(l)$\\textsuperscript{13}& D-MUX~\\\\\\hline\n\t\t\t\t\t\tGNNUnlock~&key gates removal&OL&GL/C,S/ST&GNN&ISCAS'85, ITC'99&Anti-SAT, TTLock, SFLL-HD&\\xmark\\textsuperscript{12}&\\xmark&$\\{8,\\cdots,128\\}$&$[100.00]$\\textsuperscript{11}&$\\bigO(n)$\\textsuperscript{13}&\\omark\\\\\n\t\t\t\t\t\t\\midrule\n\t\t\t\t\t\t\\midrule\n\t\t\t\t\t\tBOCANet~& key retrieval & OG\\textsuperscript{2}&GL/C/FU&D-RNN \\& LSTM& Trust-Hub, ISCAS'85&RLL&\\cmark&\\xmark & $\\{32,64,128,256\\}$&$[89.00, 100.00]$&$\\bigO(\\alpha)$\\textsuperscript{19}&\\omark\\\\\\hline\n\t\t\t\t\t\tSURF~&key retrieval& OG &GL/C,S\\textsuperscript{1}/ST,FU&SAIL \\& heuristic optimization&ISCAS'85&RLL, SLL, CS&\\xmark\\textsuperscript{3}&\\xmark&$\\{4,\\cdots,192\\}$\\textsuperscript{4} &$[90.58,98.83]$&$\\bigO(t)$\\textsuperscript{13}&UNSAIL~\\\\\\hline\n\t\t\t\t\t\tGenUnlock~&key retrieval& OG &GL/C,S/FU&GA&ISCAS'85, MCNC&RLL,SLL, AND-OR, FLL&\\cmark&\\xmark&$\\{8,\\cdots, 1618\\}$\\textsuperscript{7}&$[100.00]$\\textsuperscript{8}&$\\bigO(\\beta)$\\textsuperscript{20}&\\omark\\\\\\hline\n\t\t\t\t\t\tNNgSAT~&key retrieval& OG &GL/C,S/FU&MPNN&ISCAS'85, ITC'99&SAT-hard\\textsuperscript{5}&\\cmark&\\cmark&n/a\\textsuperscript{5}&$[93.50]$\\textsuperscript{6}&$\\bigO(\\lambda)$\\textsuperscript{18}&\\omark\\\\\t\\hline\n\t\t\t\t\t\tPSO Attack~&key retrieval& OG\\textsuperscript{9} &GL/C,S/FU&PSO&ISCAS'85, ITC'99&RLL, OLL&\\cmark&\\xmark&$\\{64,128\\}$&$[82.07,99.80]$\\textsuperscript{10}&$\\bigO(\\gamma)$\\textsuperscript{21}&point-function locking~\\\\\n\t\t\t\t\t\t\\bottomrule\n\t\t\t\t\t\\end{tabular}\n\t\t\t\t\t\\begin{tablenotes}\n\t\t\t\t\t\t\\scriptsize\n\t\t\t\t\t\t\\item [1]~~The attack is in theory applicable to sequential circuits, however no evaluation has been performed yet.\n\t\t\t\t\t\t\\item [2]~~The attack relies on having access to at least some golden input/output patterns ($<0.5\\%$ of total I/O pairs).\n\t\t\t\t\t\t\\item [3]~~In theory, the key-refinement search algorithm could be utilized based on any seed key. However, this has not been addresses thus far.\n\t\t\t\t\t\t\\item [4]~~The following key lengths have been evaluated: $\\{4,8,16,24,32,64,96,128,192\\}$.\n\t\t\t\t\t\t\\item [5]~~$n\\times m$ bitwise multipliers $(8<m,n<32)$,  $n\\times m$ crossbar network of 2-to-1 MUXes $(16<m, n<36)$,  $n$-input LUTs built by 2-to-1 MUXes $(n<16)$, and $n$-to-1 AND-trees.\n\t\t\t\t\t\t\\item [6]~~Indicates the percentage of successfully de-obfuscated circuits compared to the baseline~.\n\t\t\t\t\t\t\\item [7]~~The key length is selected based on an area overhead of 5\\%, 10\\% or 25\\%.\n\t\t\t\t\t\t\\item [8]~~The quality of the retrieved approximate keys is quantified by a user-defined output-fidelity measure.\n\t\t\t\t\t\t\\item [9]~~The attack relies on an oracle without access to the scan chain.\n\t\t\t\t\t\t\\item [10]~Accuracy refers to the average number of cases where the retrieved key results in 0\\% erroneous outputs for $10^{6}$ random patterns.\n\t\t\t\t\t\t\\item [11]~The accuracy refers to the successful removal of the locking circuitry (not the key retrieval).\n\t\t\t\t\t\t\\item [12]~The attack has not been evaluated for other locking schemes so far and the post-processing steps are scheme-specific.\n\t\t\t\t\t\t\\item [13]~Notation: the key length $l$, the number of netlist nodes $n$, the total number of iterations $t=p\\cdot{n} + p\\cdot{w}+r\\cdot{l}\\cdot{i}\\cdot{n}+r\\cdot{l}\\cdot{i}\\cdot{p}$, where $p$ is the number of output pins, $i$ is the number of IO pairs, $r$ is the number of runs, and $w$ is the number of wires.\n\t\t\t\t\t\t\\item [14]~GSS refers to the generalized set scenario which trains the ML model based on a set of locked benchmarks that are different from the target. SRS captures the self-referencing scenario where the training data is generated by re-locking the target benchmark.\n\t\t\t\t\t\t\\item [15]~If the output of the attack is an exact result, the attack can guarantee a 100\\% correct deobfuscation for the complete I/O space.\n\t\t\t\t\t\t\\item [16]~ISCAS'85~, MCNC~, ITC'99~, RISC-V Ariane core~, and Trust-Hub~.\n\t\t\t\t\t\t\\item [17]~If the time complexity can be clearly determined, it refers to the time complexity after the training process.\n\t\t\t\t\t\t\\item [18]~The execution time of the SAT attack is $\\sum_{i=1}^{\\lambda}{t_{i}}$, where $\\lambda$ is the number of iterations and $t_{i}$ the time required for one SAT-solver call. $\\lambda$ depends on the characteristics of the search space and the branching preferences of the SAT solver. Therefore, the time complexity of the attack is typically measured in terms of $\\lambda$. More details can be found in~.\n\t\t\t\t\t\t\\item [19]~The complexity is linear to the number of training samples $\\alpha$, as the final key is determined based on the MSE of the trained outputs and the key-induced generated outputs.\n\t\t\t\t\t\t\\item [20]~$\\beta=g\\cdot{p}\\cdot{l}$, where $g$ is the number of generations, $p$ is the population size, and $l$ is the key length. Note that the complexity changes with any adaptations of the GA.\n\t\t\t\t\t\t\\item [21]~$\\gamma=g\\cdot{p}\\cdot{\\delta}$, where $g$ is the number of generations, $p$ is the population size, and $\\delta$ the complexity of performing circuit simulation for the fitness evaluation.\n\t\t\t\t\t\t\\item [22]~An empirical evaluation of the resilience against SAIL has not been presented in the paper; only a discussion based on a proposed metric system has been provided.\n\t\t\t\t\t\\end{tablenotes}\n\t\t\t\t\\end{threeparttable}\n\t\t\t}\n\t\t\t\\vspace{-0.1in}\n\t\t\\end{table*}", "cites": [2932, 7636, 2931], "cite_extract_rate": 0.10344827586206896, "origin_cites_number": 29, "insight_result": {"type": "comparative", "scores": {"synthesis": 3.5, "critical": 3.0, "abstraction": 3.0}, "insight_level": "medium", "analysis": "The section provides a clear comparative overview of oracle-less ML-based attacks on logic locking, including SAIL, SnapShot, and GNNUnlock, and explains their differing approaches and objectives. It integrates information from the cited works to highlight unique characteristics of each attack method. However, it lacks deeper critical evaluation or abstraction into broader principles, focusing more on contrasting specific techniques."}}
{"id": "eda58d36-635e-44a7-9a87-c2f7c7682303", "title": "Oracle-Guided Attacks", "level": "subsubsection", "subsections": [], "parent_id": "8a41fbf8-901a-45b8-9e50-9a86985de29d", "prefix_titles": [["title", "Logic Locking at the Frontiers of Machine Learning: A Survey on Developments and Opportunities"], ["section", "Logic Locking in the Machine Learning Era"], ["subsection", "ML-Based Attacks"], ["subsubsection", "Oracle-Guided Attacks"]], "content": "Due to the availability of an oracle, existing ML-based attacks in this class have mostly exploited functional features of the target IC. This class includes the following attacks: BOCANet~, SURF~, GenUnlock~, NNgSAT~, and the PSO-guided attack~.\n\t\t\\textbf{BOCANet:}~This attack leverages Recurrent Neural Networks (RNN) based on long short-term memory to construct a correct activation key (Fig.~\\ref{fig:attack-visualization}~(d)). The ML model is trained on a sequence of I/O observations  taken from an activated IC, thereby learning the functional I/O mapping of the circuit, i.e., its Boolean function. Once trained, the key retrieval consists of two steps. First, a random key is applied to the model as input. Second, the initial key value is subsequently updated based on the Mean-Squared-Error (MSE) of the trained outputs and the newly generated outputs that are affected by the introduced key. Note that the ML model can be utilized to predict correct inputs or outputs as well. BOCANet exploits the functional effect a correct key has on generating a correct I/O mapping.\n\t\t\\textbf{SURF:}~This attack is based on a joint structural and functional analysis of the circuit to retrieve the activation key (Fig.~\\ref{fig:attack-visualization}~(e)). The ML-aspect of the attack lies in \\textit{utilizing the SAIL attack} to generate the pre-resynthesis netlist structures and a seed key. Afterwards, based on the outputs of SAIL, SURF iteratively refines the key by means of a structure-aware greedy optimization algorithm guided by a functional simulation of the obfuscated netlist and a set of golden I/O pairs. The optimization is guided by the observation that specific key gates only affect a specific set of outputs. Thus, the key bits can be partitioned based on which output they affect. Performing a systematic perturbation of the key bits can lead to a more refined key. The success of the heuristic is grounded in the limited local effects that traditional locking schemes have on the value of the output for incorrect keys.\n\t\t\\textbf{GenUnlock:}~The attack flow of GenUnlock leverages a Genetic Algorithm (GA)-based exploration of suitable activation keys for a locked circuit (Fig.~\\ref{fig:attack-visualization}~(f)). The heuristic search is steered by the key fitness that is computed based on the matching ratio of the key on the golden I/O training set. Through multiple generations, the fitness of the key population is subsequently improved through the application of genetic operators (selection, crossover, and mutation). Once the accepted tolerance for the correctness of the key is reached, the algorithm returns the set of the fittest keys. Similarly to SURF, GenUnlock exploits the fact that a heuristic key-refinement procedure eventually leads to more accurate activation keys. \n\t\t\\textbf{NNgSAT:}~The main objective of NNgSAT is the deployment of a Message-Passing Neural Network (MPNN) to facilitate the resolution of SAT-hard circuit structures during the application of a SAT-based attack (Fig.~\\ref{fig:attack-visualization}~(g)). The motivation is driven by the fact that common SAT solvers run into scalability issues when tackling hard-to-be-solved locked circuit structures, e.g, multipliers and AND trees. Therefore, in NNgSAT, a neural network is trained to predict the satisfying assignment on a set of SAT-hard cases. In deployment, the SAT-attack flow offloads the SAT-hard problems to the trained model to speed up the attack procedure. The effectiveness of NNgSAT lies in the fact that it is possible to transfer prediction knowledge from learned clauses to unseen problems.  \n\t\t\\textbf{PSO-guided Attack:}~This attack is based on a Particle Swarm Optimization (PSO) heuristic that searches through the key space directed by a selected cost function (Fig.~\\ref{fig:attack-visualization}~(f)). The cost function is modeled as the Hamming distance between the golden and the obtained output responses (for a selected key). Therefore, the search algorithm relies on having access to an activated IC to compare against. A major motivator for this attack is its applicability without having access to an open scan chain, as this is often a limiting factor for SAT-based attacks. In essence, the PSO-guided attack and GenUnlock are similar in nature, as both rely on black-box evolutionary procedures guided by a functionality-driven objective function.", "cites": [7636], "cite_extract_rate": 0.16666666666666666, "origin_cites_number": 6, "insight_result": {"type": "descriptive", "scores": {"synthesis": 2.5, "critical": 2.0, "abstraction": 2.0}, "insight_level": "medium", "analysis": "The section provides a descriptive overview of oracle-guided ML-based attacks on logic locking by summarizing the methods of BOCANet, SURF, GenUnlock, NNgSAT, and the PSO-guided attack. It integrates some ideas (e.g., the use of functional simulation and heuristic key refinement), but the synthesis is limited to connecting each paper's approach without a unifying framework. There is minimal critical analysis or abstraction, as the section mainly explains what each attack does rather than evaluating their effectiveness, limitations, or broader implications."}}
{"id": "b5e83d76-9451-4150-b043-b622bb4e368c", "title": "ML-Resilient Schemes", "level": "subsection", "subsections": [], "parent_id": "cb342b15-09e2-41e4-9c1f-0d7558736604", "prefix_titles": [["title", "Logic Locking at the Frontiers of Machine Learning: A Survey on Developments and Opportunities"], ["section", "Logic Locking in the Machine Learning Era"], ["subsection", "ML-Resilient Schemes"]], "content": "\\textbf{UNSAIL:}~This logic locking scheme has been developed to thwart attacks that target the resolution of structural transformations of logic synthesis~. The core idea of UNSAIL is to generate confusing training data that leads to false predictions in the CPM and RM modules of SAIL. This is realized through the additional manipulation of the netlist after synthesis to force the existence of \\textit{equivalent} netlist sub-graph observations that are linked to \\textit{different} key values.\n\t\t\\textbf{SARO:}~The Scalable Attack-Resistant Obfuscation (SARO) operates in two steps~. First, SARO splits the design into smaller partitions to maximize the structural alterations in the netlist. Second, a systematic truth table transformation is deployed to lock the partitions. In order to increase the complexity of pattern recognition attacks (such as SAIL), the transformations aim to maximize randomness in the netlist.\n\t\t\\textbf{Point-Functions and PSO:} As mentioned in Table~\\ref{table:attacks}, the PSO-guided attack is not applicable to point-function-based locking schemes. The reason is that this type of locking yields SAT-resilient behavior in which any incorrect key corrupts only \\textit{a very limited amount of outputs}. Consequently, this behavior offers no advantage in the guidance of the heuristic search, as it does not yield differentiating fitness values. Note that the applicability of point functions depends on the design of the fitness function that is used to guide the heuristic.\n\t\t\\textbf{D-MUX:} The recently introduced Deceptive Multiplexer (D-MUX) LL scheme builds on the concept of multiple MUX-based insertion strategies that create structural paths that are equally likely to be driven by 0 or 1 key values~. Hence, D-MUX offers efficient protection against data-driven attacks.", "cites": [2932, 2931], "cite_extract_rate": 0.6666666666666666, "origin_cites_number": 3, "insight_result": {"type": "descriptive", "scores": {"synthesis": 2.0, "critical": 2.0, "abstraction": 2.0}, "insight_level": "low", "analysis": "The section provides a straightforward description of four logic locking schemes (UNSAIL, SARO, Point-Functions and PSO, D-MUX) and their approaches to resisting machine learning attacks. It integrates information from the cited papers to explain their mechanisms but lacks deeper synthesis, critical evaluation, or abstraction into broader trends. The content remains focused on summarizing each scheme without establishing a cohesive framework or identifying overarching principles."}}
