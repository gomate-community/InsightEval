{"id": "7fcf47b3-6a7c-46cc-afa5-5ea71922a855", "title": "Introduction", "level": "section", "subsections": ["b8107d71-c4b6-4382-bf75-5adafc902ff7", "bd2ddec6-f05f-4609-a914-7d97684f0510", "a9860064-4a88-4044-a4e8-bc7acbf8360b"], "parent_id": "2f4b0bae-709d-4d09-b856-92d94c793465", "prefix_titles": [["title", "Survey of Transient Execution Attacks"], ["section", "Introduction"]], "content": "\\label{sec:intro}\nIn the past decades, computer architects have been working hard to improve the performance of computing systems.\nDifferent optimizations have been introduced in the various processor micro-architectures to improve the performance,\nincluding pipelining, out-of-order execution, and branch prediction~.\nSome of the optimizations require aggressive speculation of the executed instructions.\nFor example, while waiting for a conditional branch to be resolved, branch prediction will predict whether the branch will be taken or not,\nand the processor begins to execute code down the predicted control flow path before the outcome of the branch is known.\nSuch speculative execution of instructions causes the micro-architectural state of the processor to be modified.\nThe execution of the instructions down the incorrect speculated path is called the {\\em transient execution} -- because\nthe instructions execute transiently and should ideally disappear with no side-effects if there was mis-speculation.\nWhen a mis-speculation is detected, the architectural and micro-architectural side effects should be cleaned up -- but it is not done so today, leading to a number of recently publicized transient execution attacks~ \\hl{that leak data across different security boundaries in computing systems.}\nToday's processor designs aim to ensure the execution of a program results in architectural states as if each instruction is\nexecuted in the program order.\nAt the Instruction Set Architecture~(ISA) level, today's processors behave correctly.\nUnfortunately, the complicated underlying micro-architectural states, due to different optimizations, are modified during the transient execution, and the various transient execution attacks have shown that data can be leaked from the micro-architectural states.\nFor example, timing channels can lead to information leaks that can reveal some of the micro-architectural states which are not visible\nat the ISA level~.\n\\hl{Especially, the micro-architectural states of a processor \nare today not captured by the ISA specification, and there are micro-architectural vulnerabilities that cannot be found or analyzed by only examining the processor's ISA.}\nBesides focusing on pure performance optimization, many processors are designed to share hardware units in order to reduce area and improve power efficiency.\nFor example,\nhyper-threading allows different programs to execute concurrently on the same processor pipeline by sharing\nthe execution and other functional units among the hardware threads in the pipeline.\nAlso, because supply voltage does not scale with the size of the transistors~,\nmodern processors use multi-core designs.\nIn multi-core systems, caches, memory-related logic, and peripherals are shared among the different processor cores.\nSharing of the resources has led to numerous timing-based side and covert channels~ -- the channels can occur independent of transient execution, or together with transient execution, which is the focus of this survey. \n\\begin{figure*}[t]\n\\includegraphics[width=4.5in]{gfx/attack_phase.pdf}\n\\caption{\\small Phases of transient execution attacks. }\n \\label{fig:attack_phase}\n\\end{figure*}\nTransient execution combined with covert channels results in {\\em transient execution attacks} which can\ncompromise the confidentiality of the system. As shown in Figure~\\ref{fig:attack_phase},\nduring such attacks, the secret or sensitive data is available during transient execution\n-- this differentiates the transient execution attacks from conventional covert channel attacks where the data is assumed to be always available to the sender, not just during transient execution\\footnote{There are also attacks using the timing difference in transient execution, e.g., . These attacks are still conventional covert channel attacks, where the timing difference comes from the prediction units. Thus, these attacks are not in the scope of this paper, but are listed in Section~\\ref{sec:related_attacks}.}. \nAfter the secret data is accessed during transient execution and encoded into a covert channel, the secret data\ncan be later extracted by the attacker from the covert channel.\nA number of transient execution attack variants has been demonstrated, e.g.,\nSpectre~, Meltdown~,\nForeshadow~, LazyFP~,\nMicro-architectural Data Sampling (MDS)~, Load Value Injection (LVI)~.\nThese attacks have been shown to allow data leaks across different security boundaries, e.g., system privilege level, SGX enclave, sandbox, etc.\n\\hl{The transient execution attacks have been assigned 9 Common Vulnerabilities and Exposures (CVE) IDs out of 14 CVE IDs that correspond to vulnerabilities about gaining information on Intel products in 2018, and 4 out of 9 in 2019, according to the CVE Details database}~. \\hl{These attacks also affect other vendors, such as AMD or Arm, for example. }\nIn addition, these attacks have raised a lot of interest, and motivated computer architects to rethink the design of processors and propose a number of hardware defenses~ -- this survey summarizes the attacks and the hardware defenses, while software-based defenses are summarized in existing work~.", "cites": [1365, 7343, 1362, 1366, 1361, 1364, 7347, 1363, 7344, 7346, 7345, 1360], "cite_extract_rate": 0.3333333333333333, "origin_cites_number": 36, "insight_result": {"type": "analytical", "scores": {"synthesis": 4.0, "critical": 3.0, "abstraction": 3.5}, "insight_level": "medium", "analysis": "The section effectively synthesizes key concepts from the cited papers, such as the mechanisms of speculative execution and the role of covert channels in transient execution attacks. It provides an analytical overview of the broader implications for processor design and security. While it identifies important patterns and motivations across works, it lacks deeper critical evaluation of individual papers' limitations or comparative strengths and weaknesses."}}
{"id": "a449f265-2e15-4dea-a5bb-c16581af2086", "title": "Attacker's Goal: Breaking Security Boundaries", "level": "subsection", "subsections": [], "parent_id": "72738b70-3d67-4913-883a-4dac5223aebb", "prefix_titles": [["title", "Survey of Transient Execution Attacks"], ["section", "Threat Model"], ["subsection", "Attacker's Goal: Breaking Security Boundaries"]], "content": "\\label{sec:attacker_goal}\n\\begin{figure}[t]\n\\includegraphics[width=4in]{gfx/security_boundary-crop.pdf}\n\\caption{\\small Security boundaries in computer systems that are broken by transient execution attacks.}\n\\label{fig:security_boundary}\n\\end{figure}\nThere are many security boundaries (between different privilege levels or security domains) in a typical processor, as shown in Figure~\\ref{fig:security_boundary}.\nThe goal of the attacker of the transient execution attacks is to cross the security boundaries to obtain information related to the victim's secret data. \nWe categorize the possible privilege levels or security domains where the attack can originate, shown as red arrows in Figure~\\ref{fig:security_boundary}, and wherefrom it is trying to extract data as follows:\n\\begin{enumerate} \n\\item \\textbf{user-level program attacking another user-level program:}\nThe attacker and the victim are two separate user applications, \\hl{e.g., the attacker process tries to learn the memory content of another process}.  \\hl{demonstrates when an victim OpenSSH server process is running, how an attacker process learns the host private key.}\n\\item \\textbf{user-level program attacking the kernel:}\nThe attacker runs in the user level and wants to read the privileged data of the kernel, \\hl{e.g., }\\hl{ demonstrate an attack that dumps kernel memory from an unprivileged application.}\n\\item \\textbf{virtual machine attacking another virtual machine:}\nThe attacker and the victim reside in two different guest virtual machines, \\hl{e.g.,} \\hl{ shows it is possible for an attacker VM to learn the private key of OpenSSH server in victim VM.} \n\\item \\textbf{virtual machine attacking the hypervisor:}\n\\hl{The attacker is a guest OS and the victim is the host hypervisor e.g.,}~\\hl{ demonstrate an attack against KVM that leaks host memory when the attacker has full control of the OS inside VM.}\n\\item \\textbf{code running outside an enclave attacking victim running inside an enclave:}\nThe victim runs inside a security domain protected by some hardware scheme, e.g., SGX enclaves~, XOM~, Aegis~, Bastion~, Sanctum~ or Keystone~, and the attacker code runs outside of it. \n~ \\hl{demonstrated such an attack that retrieves secret inside the SGX enclave.}\n\\item \\textbf{attacks across security domains protected by software:}\nThe victim runs inside the security domain protected by some software scheme, e.g., sandboxes in JavaScript, and the attacker code runs outside of it, as shown in~.\n\\end{enumerate}\nIn addition, some attacks focus on \\textbf{Stale Data} stored somewhere in hardware, e.g., data remaining in registers buffers after it should have been cleaned up~.\nSometimes the stale data is of a different privilege level or security domain, so the attacker will break the security domain when accessing stale data.\n\\hl{Existing transient execution attacks can break all of the security boundaries above. Details will be discussed in Section}~\\ref{sec:consequence}, especially in Table~\\ref{tbl:privilege_level}.", "cites": [1363, 7344], "cite_extract_rate": 0.18181818181818182, "origin_cites_number": 11, "insight_result": {"type": "descriptive", "scores": {"synthesis": 2.5, "critical": 2.0, "abstraction": 2.5}, "insight_level": "medium", "analysis": "The section organizes different attack scenarios based on the privilege levels and security domains they target, which provides some structure to the cited works. However, it primarily describes these scenarios and examples from the cited papers without deeper analysis or synthesis of broader trends. There is minimal critical evaluation or abstraction to highlight general principles of transient execution attacks."}}
{"id": "fa21ac29-586c-4e50-91de-e91a1ca0cb11", "title": "Attacker's Goal: Breaking Security Boundaries", "level": "subsection", "subsections": ["879606d1-7adf-4d1a-8361-d7d97df7b922"], "parent_id": "fe310dc9-e89b-4c6e-91e7-5d2005110f30", "prefix_titles": [["title", "Survey of Transient Execution Attacks"], ["section", "Transient Execution Attack Scenarios"], ["subsection", "Attacker's Goal: Breaking Security Boundaries"]], "content": "\\label{sec:attacker_goal}\nThere are many security boundaries (between different privilege levels or security domains) in a typical processor, as shown in Figure~\\ref{fig:security_boundary}.\nThe goal of the attacker of the transient execution attacks is to cross the security boundaries to obtain information related to the victim's protected data. \nIn Figure~\\ref{fig:security_boundary}, we categorize the possible privilege levels or security domains where the attack can originate and wherefrom it is trying to extract data as follows:\n\\begin{enumerate} \n\\item \\textbf{Across user-level applications:}\nThe attacker and the victim are two separate user applications, \\hl{and the attacker process tries to learn the memory content of another process, e.g.,}~\\hl{ demonstrates how an attacker process learns the private key when a victim OpenSSH server process is running in.}\n\\item \\textbf{User-level program attacking the kernel:}\nThe attacker runs in the user level and wants to read the privileged data of the kernel, \\hl{e.g., }\\hl{ demonstrates an attack that allows an unprivileged application to dump kernel memory.}\n\\item \\textbf{Virtual machine attacking another virtual machine:}\nThe attacker and the victim resides in two different guest virtual machines, \\hl{e.g.,} \\hl{ shows it is possible for an attacker VM to learn the private key of OpenSSH server in the victim VM.} \n\\item \\textbf{Virtual machine attacking the hypervisor:}\n\\hl{The attacker is a guest OS and the victim is the host hypervisor, e.g.,}~\\hl{ demonstrates an attack against KVM that leaks hypervisor's memory when the attacker has full control of the OS inside a VM.}\n\\item \\textbf{Attacking the victim running inside an enclave:}\nThe victim runs inside a security domain protected by some hardware scheme, e.g., SGX enclaves~, XOM~, Aegis~, Bastion~, Sanctum~ or Keystone~, and the attacker code runs outside of it,\ne.g.,~ \\hl{demonstrates such an attack that retrieves secret from inside the SGX enclave.}\n\\begin{figure}[t]\n\\includegraphics[width=1.8in]{gfx/security_boundary-crop.pdf}\n\\caption{\\small Security boundaries in computer systems that are broken by transient execution attacks.}\n\\label{fig:security_boundary}\n\\end{figure}\n\\item \\textbf{Across security domains protected by software:}\nThe victim runs inside the security domain protected by some software scheme, e.g., sandboxes in JavaScript, and the attacker code runs outside of it, as shown in~.\n\\end{enumerate}\n\\hl{All of the security boundaries listed above are broken by one or more of the existing transient execution attacks. The attacks have been shown to be able to retrieve coherent data, as well as  non-coherent data.  Details will be discussed in Section}~\\ref{sec:consequence}, especially in Table~\\ref{tbl:privilege_level}.", "cites": [1363, 7344], "cite_extract_rate": 0.2, "origin_cites_number": 10, "insight_result": {"type": "analytical", "scores": {"synthesis": 4.0, "critical": 2.5, "abstraction": 3.5}, "insight_level": "medium", "analysis": "The section synthesizes information from cited papers by organizing transient execution attacks according to the attacker's goal of breaking various security boundaries. It provides a clear and structured overview, linking different attack scenarios to the core concept of speculative execution. While it offers some abstraction by identifying common attack patterns across privilege levels and domains, it lacks deeper critical evaluation of the cited works' strengths, weaknesses, or trade-offs. The analysis is informative but primarily focused on classification rather than critique or synthesis of broader implications."}}
{"id": "879606d1-7adf-4d1a-8361-d7d97df7b922", "title": "Attacks Targeting Coherent and Non-Coherent Data", "level": "subsubsection", "subsections": [], "parent_id": "fa21ac29-586c-4e50-91de-e91a1ca0cb11", "prefix_titles": [["title", "Survey of Transient Execution Attacks"], ["section", "Transient Execution Attack Scenarios"], ["subsection", "Attacker's Goal: Breaking Security Boundaries"], ["subsubsection", "Attacks Targeting Coherent and Non-Coherent Data"]], "content": "\\hl{We categorize all the data in the processor state into \\textbf{coherent data} and \\textbf{non-coherent data}. \\textit{Coherent data} are those coherent with the rest of the system, e.g., data in caches are maintained by cache coherence protocol. Coherent data can be accessed by its address. \\textit{Non-coherent data} are temporarily fetched into micro-architectural buffers or registers, are not synchronized with the rest of the system, and may not be cleaned up after use, e.g., data in the STL buffer. Thus, non-coherent data may be {stale}.\nNon-coherent data that is left in the buffer can be of a different privilege level or security domain, so the attacker will break the security domain when accessing the non-coherent stale data.} Some attacks~ \nfocus on attacking buffers to retrieve {such non-coherent data}, which in turn  breaks the security boundaries.", "cites": [7345], "cite_extract_rate": 0.5, "origin_cites_number": 2, "insight_result": {"type": "analytical", "scores": {"synthesis": 3.0, "critical": 2.0, "abstraction": 3.0}, "insight_level": "medium", "analysis": "The section provides a conceptual framework by distinguishing between coherent and non-coherent data and explains how non-coherent data can be exploited in transient execution attacks. It references Paper 1 to support this idea, showing basic synthesis and abstraction. However, it lacks deeper critical analysis of the cited paper or alternative perspectives, limiting its insight quality to a medium level."}}
{"id": "51eda86d-c5b8-4235-b0d7-16c899cda60f", "title": "Attacker is Executing Transiently.", "level": "subsubsection", "subsections": [], "parent_id": "ae65d75e-af86-4e24-b70c-f761bc7d302d", "prefix_titles": [["title", "Survey of Transient Execution Attacks"], ["section", "Transient Execution Attack Scenarios"], ["subsection", "Transient Execution by the Victim vs. the Attacker"], ["subsubsection", "Attacker is Executing Transiently."]], "content": "As shown in Figure~\\ref{fig:attacker_loc} (e--h), the attacker can directly obtain the secret in transient execution.\nThe attacker will then encode the data into a covert channel and decode it to obtain the secret in the architectural state, such as in her memory. \nThe attacker can also launch different software threads for the setup or the decoding phases. \nThe attacker's code shown in Figure~\\ref{fig:attacker_loc} (e--h) might be in different threads, even on different cores.\nDuring the attack, the attacker directly obtains the secret during transient execution, and thus, the attacker should be able to have a pointer to the location of the victim data. \nThere might be only the attacker code running, or the attacker and the victim running in parallel.\nWhen there is only the attacker code running, the victim's protected data should be addressable to the attacker or the data is in some register in the hardware, i.e., the attacker should have a way to point to the data.\nIn Meltdown~, the attacker code first loads protected data by its virtual address to register and then transfers the data through a covert channel.\nWhen the attacker and the victim are running concurrently, the attacker should be able to partially control the victim's execution or synchronize with the victim execution.\nFor example, in Micro-architectural Data Sampling (MDS) attacks~, the attacker needs to synchronize with the victim execution to extract useful information from the non-coherent data of the victim in the buffers.\nIn micro-architectural implementations, transient execution allows the attacker to access more data than it is allowed in the architecture (ISA) level. Thus, this type of attack is implementation-dependent and does not work on all the CPUs, e.g., Meltdown~, Foreshadow~, MDS~, are reported to work on Intel processors.\nSimilar to the case when the victim is executing transiently, the setup phases and decoding phases can also be done by the victim, resulting in four attack scenarios in Figure~\\ref{fig:attacker_loc} (e--h). However, in the current known attacks, the attacker always sets up, triggers the transient execution, and decodes from the channel, which is more practical.", "cites": [1361, 7343], "cite_extract_rate": 0.3333333333333333, "origin_cites_number": 6, "insight_result": {"type": "analytical", "scores": {"synthesis": 4.0, "critical": 2.5, "abstraction": 3.5}, "insight_level": "medium", "analysis": "The section synthesizes information from cited papers (e.g., Meltdown, MDS, ZombieLoad) by categorizing and explaining how attackers can execute transiently, and how this differs from victims executing transiently. It connects these attacks under a common framework of transient execution and covert channels. While it provides a structured analytical view, it lacks deeper critical evaluation of the limitations or differences in effectiveness between the cited attacks. It identifies broader patterns, such as the implementation dependence of attacks, but abstraction is limited to this level rather than reaching a meta-level understanding."}}
{"id": "c77580cf-3a89-4371-a1f2-3b055342929d", "title": "\\hl{Feasibility of the Attack Scenarios", "level": "subsubsection", "subsections": [], "parent_id": "ae65d75e-af86-4e24-b70c-f761bc7d302d", "prefix_titles": [["title", "Survey of Transient Execution Attacks"], ["section", "Transient Execution Attack Scenarios"], ["subsection", "Transient Execution by the Victim vs. the Attacker"], ["subsubsection", "\\hl{Feasibility of the Attack Scenarios"]], "content": "}\n\\label{sec:feasibility_scenario}\n\\begin{table*}[t]\n\\centering\n\\caption{\\small \\hl{Required Control of Victim Execution in Different Attack Scenarios.}}\n\\begin{threeparttable}\n\\small\n\\begin{tabular}{ |C{5em} || C{5em} | C{5em} |C{5em} || C{5em} | C{5.5em} | C{5em}  | }\\hline\n\\textbf{Scenario in Figure~\\ref{fig:attacker_loc}} & \\textbf{Setup Phase}  & \\textbf{Transient Execution Phase} & \\textbf{Decoding Phase}  & \\textbf{Number of Victim Gadgets to~be Triggered*} & \\textbf{Sharing Required during Transient Execution**} & \\textbf{Sharing Required for Covert Channel**}\\\\\n\\hline\na& Victim & Victim & Victim & 2-3 & No&No\\\\\nb& Victim & Victim & Attacker & 1-2 & No&Yes\\\\\n\\hline\nc& Attacker & Victim & Victim & 2 &Yes&No\\\\\nd& Attacker & Victim & Attacker &1  &Yes&Yes\\\\\n\\hline\n\\hline\ne& Victim & Attacker & Victim & 2 &Yes&Yes\\\\\nf& Victim & Attacker & Attacker & 1 &Yes&No\\\\\n\\hline\ng& {Attacker} & Attacker & Victim & 1 &No&Yes\\\\\nh& {Attacker} & Attacker & Attacker & 0 & No& No\\\\\n\\hline\n\\end{tabular}\n* The number shows the number of different code gadgets in the victim's codebase to be triggered by the attacker. \nWe assume the decoding gadget is different from the disclosure gadget. The setup gadget may or may not be the same code as the disclosure gadget, \nso the two gadgets can be counted as either $1$ (same) or $2$ (different) gadgets,\ngiving a range of gadgets required, as show in the fifth column of the table.\n** Here, we refer to sharing of hardware between the attacker and the victim. In addition, the attacker (or the victim) could also have multiple software threads running and sharing hardware between the threads. We assume colocation between the each party's threads is possible, and do not list that here.\n\\begin{tablenotes}\n\\end{tablenotes}\n\\end{threeparttable}\n\\label{tbl:pred_ctrl_victim}\n\\end{table*}\n\\hl{The required number of gadgets in the victim codebase to be triggered and required sharing in different transient execution scenarios is summarized in Table}~\\ref{tbl:pred_ctrl_victim}. In addition, Figure~\\ref{fig:attacker_loc} \\hl{shows the attack scenarios demonstrated in different publications. \nIn a practical attack, it is desired to have most phases to be executed by the attacker's code and less required sharing of hardware.}\n\\hl{In most of the existing attacks,\nthe attacker completes setup and decoding steps, as shown in Figure}~\\ref{fig:attacker_loc} \\hl{(d,h), because they use less gadgets in the victim codebase and are more practical for the attacker. Attack scenarios (a,b) in Figure}~\\ref{fig:attacker_loc} \\hl{are also demonstrated that have less requirement of shared hardware.}\nIn Spectre V1, since the victim disclosure gadget can be reused as the setup gadget for training the predictor,  triggering victim to run the setup phase does not require additional effort for the attacker, and thus, Figure~\\ref{fig:attacker_loc}~(b) is also practical.\nThe attacker can also use the victim's code to complete both setup and decoding steps, as shown in Figure~\\ref{fig:attacker_loc} (a). In this case, the attacker can launch the attack remotely~. \nScenarios (c) and (e--g) in Figure~\\ref{fig:attacker_loc}\\hl{ require more gadgets in the victim code and are not demonstrated in the publications so far. However, if the attacker has the ability to trigger the victim to execute certain gadgets (as required by some of the attacks already), those scenarios are still feasible and should be considered when designing mitigations.}", "cites": [1360], "cite_extract_rate": 1.0, "origin_cites_number": 1, "insight_result": {"type": "analytical", "scores": {"synthesis": 4.0, "critical": 3.0, "abstraction": 4.0}, "insight_level": "high", "analysis": "The section synthesizes the attack scenarios from relevant works using a structured table and reference to a figure, connecting ideas into a coherent framework. It also offers some critical analysis by evaluating the practicality and gadget requirements of different scenarios. The abstraction is strong, as it identifies broader patterns in feasibility and attacker control, contributing to a meta-level understanding of transient execution attacks."}}
{"id": "a1434b30-3403-4a4b-ae71-f8feeb87c7a5", "title": "Transient Execution", "level": "section", "subsections": ["72b2078f-6bae-4ddf-bed7-e8b4f8710c48", "fa391ee6-dea6-4242-9950-f0977d171577", "2dc47435-a05c-4f34-bd10-83e6135da759", "280841bf-fd81-4b06-9437-6c1c55848957", "a040bcfa-22fd-4877-998c-27229a8ac0bf", "cb4aac55-51a9-481a-98d8-e0bb0a27bc7b", "db7cac0e-f182-465f-94ef-6c73c1e95ba7"], "parent_id": "2f4b0bae-709d-4d09-b856-92d94c793465", "prefix_titles": [["title", "Survey of Transient Execution Attacks"], ["section", "Transient Execution"]], "content": "\\label{sec:transient_exe}\n\\hl{Transient execution is the phenomenon where code is executed speculatively, and it is not\nknown if the instructions will be committed or squashed until the retirement of the instruction or a pipeline squash event.\nUpon the squash, \nnot all the micro-architectural side effects are cleaned up properly, causing the possible \ntransient execution attacks. \nHence, all causes of pipeline squash are also causes of transient execution and need to be understood to know what cause transient execution attacks to occur.\nIn this section, we first discuss all possible causes of transient execution, \nthen we propose a set of the metrics to evaluate feasibility of the transient \nexecution attacks.}\n\\begin{table*}[t]\n\\centering\n\\caption{\\small Data Leaked by the Transient Execution Attacks.}\n\\begin{threeparttable}\n\\centering\n\\small\n\\begin{tabular}{ l | l | l | l| l|c c c c c c |c  }\n&\\multicolumn{3}{c|}{\\multirow{5}{4.5em}{\\bf Causes of Transient Execution}}  &\\multicolumn{1}{c|}{\\multirow{5}{4em}{\\bf Example Attacks}} &  \\multicolumn{6}{c|}{\\bf Coh. Data**} &  \\multirow{2}{2em}{{\\bf Non-coh. Data**}}\\\\\n &\\multicolumn{3}{l|}{} && \\rotatebox{90}{hypervisor} &  \\rotatebox{90}{across VM} & \\rotatebox{90}{kernel data} &  \\rotatebox{90}{across user app.} &  \\rotatebox{90}{SGX} &  \\rotatebox{90}{sandbox}   &  \\rotatebox{90}{}  \\\\\n\\hline\n\\multirow{10}{4.5em}{{Victim Executes {Transiently}}} \n& \\multirow{6}{2em}{{\\rotatebox{90}{Prediction}}}&\\multirow{3}{2em}{{Ctrl Flow}}&PHT&\nSpectre V1~& $\\boxtimes$ & $\\boxtimes$ &$\\boxtimes$ & $\\boxtimes$ & $\\boxtimes$ &$\\boxtimes$ & $\\Box$\\\\\n&&&BTB&Spectre V2~& $\\boxtimes$ & $\\boxtimes$ &$\\boxtimes$ & $\\boxtimes$ & $\\boxtimes$ &$\\boxtimes$ & $\\Box$\\\\\n&&&RSB&Spectre V5~& $\\boxtimes$ & $\\boxtimes$ &$\\boxtimes$ & $\\boxtimes$ & $\\boxtimes$ &$\\boxtimes$ & $\\Box$\\\\\n\\cline{3-12}\n&&\\multirow{2}{1.5em}{Addr.}& \\multirow{1}{1em}{STL}&Spectre V4, LVI~ &$\\boxtimes$ & $\\boxtimes$ &$\\boxtimes$ & $\\boxtimes$ & $\\boxtimes$ &$\\boxtimes$ & $\\boxtimes$\\\\\n&&&LFB&LVI~&$\\boxtimes$ & $\\boxtimes$ &$\\boxtimes$ & $\\boxtimes$ & $\\boxtimes$ &$\\boxtimes$& $\\boxtimes$\\\\\n\\cline{3-12}\n&&Value& \\multicolumn{8}{l}{no commercial implementation} \\\\\n\\cline{2-12}\n&\\multicolumn{2}{l|}{{Exception}}& *&LVI~&$\\boxtimes$ & $\\boxtimes$ &$\\boxtimes$ & $\\boxtimes$ & $\\boxtimes$ &$\\boxtimes$ & $\\boxtimes$\\\\\n\\cline{2-12}\n&\\multicolumn{3}{l|}{{Interrupts}}& \\multicolumn{8}{l}{no known attack}\\\\\n\\cline{2-12}\n&\\multicolumn{3}{l|}{{Load-to-load reordering}}& \\multicolumn{8}{l}{no known attack}\\\\\n\\hline\n\\multirow{12}{4.5em}{{Attacker Executes Transiently}} &  \n \\multirow{5}{2em}{{\\rotatebox{90}{Prediction}}}\n&\\multirow{1}{2em}{{Ctrl Flow}} \n&*& \\multicolumn{8}{l}{no known attack}\\\\ \n&&&\\\\\n\\cline{3-12}\n&& \\multirow{2}{2em}{Addr.}\n& STL&Fallout~ &$\\Box$ &$\\Box$ &$\\Box$ &$\\Box$ &$\\Box$ &$\\Box$ & $\\boxtimes$\\\\\n&&& LFB&RIDL, ZombieLoad~ &$\\Box$ &$\\Box$ &$\\Box$ &$\\Box$ &$\\Box$ &$\\Box$ & $\\boxtimes$ \\\\\n\\cline{3-12}\n&&Value& \\multicolumn{8}{l}{no commercial implementation} \\\\\n\\cline{2-12}\n& \\multicolumn{2}{l|}{\\multirow{5}{4em}{Exception}}& PF-US &Meltdown (V3)~ &$\\Box$ &$\\Box$ & $\\boxtimes$ & $\\Box$&$\\Box$ &$\\Box$ & $\\Box$\\\\\n&\\multicolumn{2}{l|}{}& PF-P& Foreshadow (L1TF)~ &$\\boxtimes$ &$\\boxtimes$ &$\\boxtimes$ &$\\boxtimes$ &$\\boxtimes$ &$\\Box$ &$\\Box$ \\\\\n&\\multicolumn{2}{l|}{}& PF-RW&V1.2~ &$\\Box$ &$\\Box$ &$\\Box$ &$\\Box$ &$\\Box$ &$\\boxtimes$ &$\\Box$ \\\\\n&\\multicolumn{2}{l|}{}& NM&LazyFP ~ &$\\Box$ &$\\Box$ &$\\Box$ &$\\Box$ &$\\Box$ &$\\Box$ &$\\boxtimes$ \\\\\n&\\multicolumn{2}{l|}{}& GP&V3a~&$\\Box$&$\\Box$ &$\\boxtimes$  &$\\Box$ &$\\Box$ &$\\Box$ &$\\Box$ \\\\\n\\cline{2-12}\n&\\multicolumn{3}{l|}{{Interrupts}}& \\multicolumn{8}{l}{no known attack}\\\\\n\\cline{2-12}\n&\\multicolumn{3}{l|}{{Load-to-load reordering}}& \\multicolumn{8}{l}{no known attack}\\\\\n\\hline\n\\end{tabular}\n\\begin{tablenotes}\n$\\boxtimes$ indicates that the attack can leak the protected data; $\\Box$ indicates that the attack cannot leak the data.\\\\\n* indicates all hardware components that cause the corresponding transient execution, we combine them in the same row because the data leaked in the attacks are the same.\n**{\\em Coh. Data} is short for coherent data, {\\em Non-coh. Data} is short for non-coherent data.\n\\end{tablenotes}\n\\end{threeparttable}\n\\label{tbl:privilege_level}\n\\label{tbl:spec_primitive}\n\\end{table*}", "cites": [7343, 1362, 1366, 1361, 7347, 1363, 7344, 7345, 1360], "cite_extract_rate": 0.47368421052631576, "origin_cites_number": 19, "insight_result": {"type": "comparative", "scores": {"synthesis": 3.5, "critical": 3.0, "abstraction": 3.5}, "insight_level": "medium", "analysis": "The section synthesizes multiple papers by categorizing the causes of transient execution and mapping them to specific attacks, providing a structured overview. It shows some abstraction by grouping related hardware components and identifying attack patterns, but it primarily functions as a comparative analysis by contrasting which attacks can or cannot leak certain types of data. Critical analysis is limited to noting the absence of known attacks in certain categories rather than evaluating limitations or implications in depth."}}
{"id": "72b2078f-6bae-4ddf-bed7-e8b4f8710c48", "title": "Causes of Transient Execution", "level": "subsection", "subsections": [], "parent_id": "a1434b30-3403-4a4b-ae71-f8feeb87c7a5", "prefix_titles": [["title", "Survey of Transient Execution Attacks"], ["section", "Transient Execution"], ["subsection", "Causes of Transient Execution"]], "content": "The following is an exhaustive list of possible causes of transient execution (i.e., causes of  pipeline squashing).\n\\textbf{Mis-prediction:} The first possible cause of transient execution is mis-prediction. Modern computer architectures make predictions to make full use of the pipeline to gain performance. When the prediction is correct, the execution continues and the results of the predicted execution will be used. In this way, predictions boost performance by executing instructions earlier. If the prediction is wrong, the code (transiently) executed down the incorrect (mis-predicted path) will be squashed. \nThere are three types of predictions: control flow prediction, address speculation, and value prediction.\n\\begin{enumerate}[itemindent=24pt,leftmargin=0pt,listparindent=\\parindent]\n\\item \\textbf{Control Flow Prediction:} Control flow prediction predicts the execution path that a program will follow.\nBranch prediction unit (BPU) stores the history of past branch directions and targets and leverages the locality in the program control flow to make predictions for future branches. \nBPU predicts whether the branch is to be taken or not (i.e., branch direction) by using pattern history table (PHT), and what is the target address (i.e., branch or indirect jump target) by using branch target buffer (BTB) or return stack buffer (RSB).  The implementation details of PHT, BTB, and RSB in Intel processors will be discussed in Section~\\ref{sec:Ctrl_flow_Intel}.\n\\item \\textbf{Address Speculation:}\nAddress speculation is a prediction on the address when the physical address is not fully available yet, e.g., whether two addresses are the same. It is used to improve performance in the memory system, e.g., store-to-load (STL) forwarding in the load-store queue, line-fill buffer (LFB) in the cache. The implementation details of STL and LFB in Intel processors will be discussed in Section~\\ref{sec:Addr_spec_Intel}.\n\\item \\textbf{Value Prediction:}\nTo further improve the performance, while the pipeline is waiting for the data to be loaded from memory hierarchy on a cache miss, value prediction units have been designed to predict the data value and to continue the execution based on the prediction.  \nWhile this is not known to be implemented in commercial architectures, value prediction had been proposed in the literature~. \n\\end{enumerate}\n\\textbf{Exceptions:} \nThe second possible cause for transient execution to occur are exceptions.\n\\hl{If an instruction causes an exception, the handling of the exception is sometimes delayed until the instructing is retired,  allowing code to (transiently) execute until the exception is handled. There are a number of causes of exceptions, such as a wrong permission bit (e.g., present bit, reserved bit) in Page Table Entry (PTE), etc.} A list of all the exception types or permission bit violations is summarized in . \\hl{In addition, Xiao et al. developed a software framework to automatically explore the vulnerabilities on a variety of Intel and AMD processors}~.\nSometimes the exceptions are suppressed due to another fault, e.g., nested exceptions. For example, when using transactional memory (Intel TSX~), if a problem occurs during the transaction, all the architectural states in the transaction will be rolled back by a transaction abort, suppressing the exception that occurred in the middle of the transaction~. Another way is to put the instruction that would cause exception in a mis-predicted branch.\nIn this survey, even if the exception is suppressed later, we categorize the attack to be due to exceptions.\n\\textbf{Interrupts:} The third possible cause for transient execution is (external) interrupts. If a peripheral device or a different core causes an interrupt, \\hl{the processor stops executing the current program, saves the states, and transfers control to interrupt handler. In one common implementation, when stoping execution, the oldest instruction in the ROB will finish execution, and all the rest of the instructions in the ROB will be squashed, the instructions that were executed after the oldest instruction (but end up being squashed) are executed transiently.}\nAfter the interrupt is handled, the current program may continue the execution, i.e., the instructions that are squashed will be fetched into the pipeline again.\n\\textbf{Load-to-Load Reordering (Multi-Core):} \nThe fourth possible cause for transient execution is load-to-load reordering. Current x86 architectures use the total store order~(TSO) memory model~.  \\hl{In TSO, all observable load and store reordering are not allowed except store to load reordering where a load bypasses an older store of a different address.} To prevent a load to load reordering, if a load has executed but not yet retired and the core receives a cache invalidation for the line read by the load, the pipeline will be squashed. Transient execution occurs between the instruction issue and when the load-to-load reordering is detected.", "cites": [1365, 7343], "cite_extract_rate": 0.25, "origin_cites_number": 8, "insight_result": {"type": "descriptive", "scores": {"synthesis": 2.5, "critical": 2.0, "abstraction": 2.5}, "insight_level": "medium", "analysis": "The section provides a clear and factual description of the causes of transient execution, drawing from the cited papers. It integrates basic concepts from both papers by mentioning exception-based attacks and the influence of Meltdown on new attack classes, but the synthesis remains limited and does not create a novel framework. There is little critical analysis of the cited works, and while some general patterns (e.g., exception handling and speculative mechanisms) are mentioned, the abstraction is not extended to a meta-level understanding of transient execution phenomena."}}
{"id": "fa391ee6-dea6-4242-9950-f0977d171577", "title": "Causes of Transient Execution in Known Attacks", "level": "subsection", "subsections": [], "parent_id": "a1434b30-3403-4a4b-ae71-f8feeb87c7a5", "prefix_titles": [["title", "Survey of Transient Execution Attacks"], ["section", "Transient Execution"], ["subsection", "Causes of Transient Execution in Known Attacks"]], "content": "Not all transient execution can be leveraged in an attack,\nand Table~\\ref{tbl:spec_primitive} shows the causes of transient execution in existing attacks.\nMis-prediction is leveraged in Spectre-type attacks, e.g.,~. Address speculation is leveraged in MDS attacks~ and LVI~. Exceptions of loads or stores are leveraged in Meltdown attacks~, Foreshadow attacks~, and LVI~, etc.\nOther types of exceptions, interrupts, and load-to-load reordering are not considered to be exploitable. Because the instructions that get squashed due to exceptions, interrupts and load-to-load, are legal to be resumed later on, and no  extra data is accessible to the attacker during the transient execution.\nThe sample codes of different variants are shown in Figure~\\ref{fig:spectre_sample}. The victim code should allow a potential mis-prediction or exception to happen. In Spectre V1~, to leverage PHT, a conditional branch should  exist in the victim code followed by the gadget. Similarly, in Spectre V2~ and V5~, the victim code should have an indirect jump (or a return from a function) that uses BTB (or RSB) for prediction of the execution path. In Spectre V4~, to use STL, the victim code should have a store following a load having potential address speculation.\n\\hl{In LVI}~\\hl{, a load that triggers a page fault (accessing} {\\tt trusted\\_ptr}\\hl{) will forward non-coherent data in the store buffer which is injected by a malicious store (}{\\tt *arg\\_copy = untrusted\\_ptr}\\hl{), and then, the secret data addressed by the injected value (}{\\tt **untrusted\\_ptr}\\hl{) is leaked.\nIn Meltdown}~\\hl{, the attacker code should make  an illegal load to cause an exception. \nIn MDS attack}~\\hl{, a faulty load (}{\\tt value=*(new\\_page)}\\hl{) will forward non-coherent data in the buffer.}\n\\begin{figure*}[t]\n\\includegraphics[width=4.5in]{gfx/spectre_sample-crop.pdf}\n\\caption{\\small Example code of transient execution attacks. Code highlighted in orange triggers transient execution. Code highlighted in yellow with dashed frame is the disclosure gadget.}\n \\label{fig:spectre_sample}\n\\end{figure*}", "cites": [7347, 1366, 1363, 1361, 7343], "cite_extract_rate": 0.45454545454545453, "origin_cites_number": 11, "insight_result": {"type": "analytical", "scores": {"synthesis": 4.0, "critical": 3.0, "abstraction": 3.5}, "insight_level": "medium", "analysis": "The section effectively synthesizes multiple papers by categorizing the causes of transient execution in different attacks, such as mis-prediction, address speculation, and exceptions. It provides a coherent overview of how each attack leverages specific microarchitectural behaviors. However, while it identifies which types of exceptions are and are not exploitable, it lacks deeper critical evaluation of the cited works' limitations or trade-offs. The section offers some level of abstraction by generalizing how certain behaviors (e.g., resuming legal instructions after exceptions) prevent exploitation, but it does not develop a novel, overarching framework."}}
{"id": "280841bf-fd81-4b06-9437-6c1c55848957", "title": "Security Boundaries that are Broken", "level": "subsection", "subsections": [], "parent_id": "a1434b30-3403-4a4b-ae71-f8feeb87c7a5", "prefix_titles": [["title", "Survey of Transient Execution Attacks"], ["section", "Transient Execution"], ["subsection", "Security Boundaries that are Broken"]], "content": "\\label{sec:consequence}\nAs discussed in Section~\\ref{sec:attacker_goal}\\hl{, the attacker's goal is to access the coherent or non-coherent data across the security boundaries in the system.} \nTable~\\ref{tbl:privilege_level} \\hl{lists the type of data and the security boundaries across which the data can be leaked in the known transient execution attacks, assuming all the instructions in the disclosure gadget can execute transiently and the covert channel can transmit information to the attacker.}\n\\hl{If the victim is executing transiently, the disclosure gadget can read any coherent data that the victim could access architecturally, \neven if the semantics of the victim code do not intend it to access the data}~. \n\\hl{Hence, in these attacks, the attacker can break the isolation between the victim and the attacker and learn data in the victim's domain.}\nFor example, SWAPGS instruction is a privileged instruction that usually executed after switching from user-mode to kernel-mode. If SWAPGS is executed transiently in the kernel-mode in the incorrect path, kernel data can be leaked~.\n\\hl{When the victim is executing transiently, the attacker can also learn the non-coherent data (for example, stale data) and also data that depends on non-coherent data (e.g., data in an address that is depended on non-coherent data).\nFor example, in Spectre V4}~, \\hl{stale data that contains the address of the secret data in the store buffer is forwarded to the younger instructions transiently, and the disclosure gadget accesses and transmits the secret data to the attacker. \nAs another example, in LVI attack}~\\hl{, the attacker injects malicious value through buffers, such as STL or LFB, causing a victim's transient execution that depends on a value controlled by the attacker and potentially leaks the value in address controlled by the attacker.} \n\\hl{If the attacker is executing transiently, transient execution allows the attacker to access illegal data directly.} \nAs shown in Table~\\ref{tbl:privilege_level}\\hl{, the security boundaries that are broken depend on the causes of transient execution.} \nIn some processor implementations, even if a load causes an exception due to permission violation, the coherent data might still be propagated to the following instructions and  learned by the attacker.\nFor example, in Meltdown~, privileged data is accessible transiently to an unprivileged user even if the privileged bit in the page table is set.\nIn L1 terminal fault (L1TF)~, secret data in the L1 cache is accessible transiently even if the present bit in the page table is not set.\nIn Table~\\ref{tbl:privilege_level}, the attacks leveraging exceptions are categorized by the cause of the exception, e.g., page fault (PF), and the related permission bit. \n\\hl{Non-coherent data present in the micro-architecture buffers (e.g., Line Fill Buffers (LFB) or store buffer (STB)) can sometimes be accessed by the attacker in transient execution}~. In addition, in CROSSTALK~, \\hl{a hardware buffer called staging buffer is discovered. The staging buffer is for some type of off-core reads, e.g., {\\tt RDRAND} instruction that requesting DRNG (Digital Random Number Generator), {\\tt CPUID} instruction that read from MachineSpecific Registers (MSRs).\nThe staging buffer is shared across cores, and thus,  the CROSSTALK paper demonstrated a cross-core attack where the victim fetch some data from RNG, and the attacker then learn the random number in the stage buffer during transient execution.}", "cites": [1363, 1361, 7343], "cite_extract_rate": 0.3, "origin_cites_number": 10, "insight_result": {"type": "analytical", "scores": {"synthesis": 4.3, "critical": 2.7, "abstraction": 4.0}, "insight_level": "high", "analysis": "The section effectively synthesizes multiple transient execution attacks, connecting them under the concept of broken security boundaries. It abstracts the underlying mechanisms by discussing coherent and non-coherent data leakage and how transient execution bypasses isolation. While it provides useful examples and categorizations, it lacks deeper critical analysis of the limitations or trade-offs of these attacks and proposed defenses."}}
{"id": "cb4aac55-51a9-481a-98d8-e0bb0a27bc7b", "title": "Required Sharing during Transient Execution", "level": "subsection", "subsections": ["f5fceee7-2e77-4e85-8c1d-dddc6a157881", "89e6daa1-889f-4d34-b58c-b5ee0a817d8c", "007b9f6b-6222-44d1-8975-184568450082"], "parent_id": "a1434b30-3403-4a4b-ae71-f8feeb87c7a5", "prefix_titles": [["title", "Survey of Transient Execution Attacks"], ["section", "Transient Execution"], ["subsection", "Required Sharing during Transient Execution"]], "content": "\\label{sec:mistrain}\n\\hl{As shown in Table}~\\ref{tbl:pred_ctrl_victim}\\hl{, in some scenarios, the setup code and the disclosure gadget are run by different parties, e.g., Figure~}\\ref{fig:attacker_loc}\\hl{ (c-f), or in attacker's different software threads, e.g., Figure}~\\ref{fig:attacker_loc}\\hl{ (g-h). These cases require that the setup code shares the same prediction unit (entry) with the disclosure gadget. \nOne common attack scenario is that the attacker mis-trains the prediction unit to lure the execution of the disclosure gadget of the victim, e.g., Figure}~\\ref{fig:attacker_loc}\\hl{ (d).\nHardware sharing can be as follows:} \n\\label{sec:colocation_attacker}\n\\begin{itemize}\n\\item \\textbf{Same thread:}  The attacker and the victim  (if both of them executing) or the attacker's software threads (if only the attacker is executing) are running on the same logical core (hardware thread) in a time-sliced setting, and there might be  context switches in between.\n\\item \\textbf{Same core, different thread:}   The attacker and the victim  (if both of them executing) or the attacker's threads (if only the attacker is executing) are running on different logical cores (hardware threads) through simultaneous multithreading (SMT) on the same physical core.\n\\item \\textbf{Same chip, different core:}  The attacker and the victim  (if both of them executing) or the attacker's threads (if only the attacker is executing) are on different CPU cores, but are sharing LLC, memory bus, and other peripheral devices.\n\\item \\textbf{Same motherboard, different chip:}  The attacker and the victim  (if both of them executing) or the attacker's threads (if only the attacker is executing) share memory bus and peripheral devices.\n\\end{itemize}\n\\label{sec:addr_space_attacker}\n\\hl{Some prediction units have multiple entries indexed by address, and in that case, the attacker needs to share the same entry of the prediction unit with the victim during the setup. To share the same entry, the attacker needs to control the address to map to the same predictor entry as the victim.}\nThe address space can be one of the following:\n\\begin{itemize}\n\\item \\textbf{In the same address space:} In this case, the attacker and the victim have the same virtual to physical address mapping.\n\\item \\textbf{In different address spaces with shared memory:} In this case, the attacker and the victim have different virtual to physical address mappings. But some of the attacker's pages and the victim's pages map to the same physical pages. This can be achieved by sharing dynamic libraries (e.g., {\\tt libc}).\n\\item \\textbf{In different address spaces without shared memory:} The attacker and the victim have different virtual to physical address mapping.  Further, their physical addresses do not overlap.\n\\end{itemize}\n\\begin{table*}[t]\n\\centering\n\\caption{\\small Level of Sharing and (Mis-)training the Prediction Unit  on Intel Processors.}\n\\begin{threeparttable}\n\\small\n\\begin{tabular}{  l l | l l l l  }\n&  \\parbox{0.7in}{\\bf Prediction Unit} &\\parbox{0.5in}{\\rotatebox{30}{\\bf same thread}} &  \\parbox{0.5in}{\\rotatebox{30}{\\bf same core, different thread}} &  \\parbox{0.6in}{\\rotatebox{30}{\\bf same chip, different core}} &  \\parbox{0.8in}{\\rotatebox{30}{\\bf same motherboard}}    \\\\\n\\hline\n\\multirow{3}{0.4in}{\\rotatebox{0}{Ctrl Flow}}  & PHT~ & f(virtual addr) &f(virtual addr) &-- & -- \\\\\n&BTB~ & {f(virtual addr)} & {f(virtual addr)}\\tnote{a}   & -- & -- \\\\\n&RSB~ & not by address\\tnote{b}& -- &-- &-- \\\\\n\\hline\n\\multirow{3}{0.4in}{\\rotatebox{0}{Addr.}}  &STL~ & f(physical addr) \\tnote{c}  & -- & --& -- \\\\\n&LFB~ & not  by address  & not  by address & --& -- \\\\\n&Other\\tnote{d} &  &  & & \\\\\n\\hline\nValue & no commercial impl.  &  &  & & \\\\\n\\hline\n\\end{tabular}\n\\begin{tablenotes}\n\\footnotesize\n``--\" indicates the prediction unit is not possible to be trained under the corresponding sharing setting;\nOtherwise, the prediction unit can be trained and\n``f(virtual addr)\" indicates the prediction unit is indexed by a function of the virtual address,\n``f(physical addr)\" indicates the prediction unit is indexed by a function of the  physical address,\n and ``not  by address\" indicates the prediction unit is not indexed by addresses.\\\\\n\\item[a] Conflicting results are presented in different publications~. \\\\\n\\item[b] Most OSes overwrite RSBs on context switches.\\\\\n\\item[c] STL is possible after context switch, but not on SGX enclave exit.\\\\\n\\item[d] In~, it is indicated that there could be other structures which forward data speculatively.\n\\end{tablenotes}\n\\end{threeparttable}\n\\label{tbl:pred_share}\n\\end{table*}\n\\hl{In the following, we discuss the level of sharing required to trigger transient execution of disclosure gadget for an attack leveraging mis-prediction. \nIn particular, the scenario depends on the implementation, and thus, we discuss each of the prediction units in Intel Processors in detail.}", "cites": [1362, 1366, 1363, 1361, 7346, 7343], "cite_extract_rate": 0.6666666666666666, "origin_cites_number": 9, "insight_result": {"type": "analytical", "scores": {"synthesis": 4.0, "critical": 3.0, "abstraction": 4.0}, "insight_level": "high", "analysis": "The section synthesizes key concepts from multiple papers on transient execution attacks, particularly focusing on how different prediction units require specific hardware and memory-sharing conditions. It provides a structured analysis of address space and core-sharing scenarios, abstracting these into general categories. While it includes some critical observations (e.g., OSes overwriting RSBs), deeper comparative analysis or evaluation of trade-offs across the cited works is somewhat limited."}}
{"id": "f5fceee7-2e77-4e85-8c1d-dddc6a157881", "title": "Control Flow Prediction:", "level": "subsubsection", "subsections": [], "parent_id": "cb4aac55-51a9-481a-98d8-e0bb0a27bc7b", "prefix_titles": [["title", "Survey of Transient Execution Attacks"], ["section", "Transient Execution"], ["subsection", "Required Sharing during Transient Execution"], ["subsubsection", "Control Flow Prediction:"]], "content": "\\label{sec:Ctrl_flow_Intel}\nTo predict the branch direction, modern branch predictors use a hybrid mechanism~. One major component of the branch predictor is the pattern history table (PHT). Typically, a PHT entry is indexed based on some bits of the branch address, so a branch at a certain virtual address will always use the same entry in the PHT. In each entry of the PHT, a saturating counter stores the history of the prior branch results, which in turn is used to make future predictions.\nTo predict the branch targets, a branch target buffer (BTB) stores the previous target address of branches and jumps. Further, a return instruction is a special indirect branch that always jumps to the top of the stack. The BTB does not give a good prediction rate on return instructions, and thus, return stack buffer (RSB) has been introduced in commercial processors. \nThe RSB stores $N$ most recent return addresses.\nIn Intel processors, the PHT and BTB\\footnote{In~, the authors did not observe BTB collision between logical cores.  However, it is demonstrated that the attacker can mis-train the indirect jump of a victim when they are two hyper-threads sharing the same physical core in~. Thus, we think BTB is shared across hyper-threads in some of the processors. }\n are shared for all the processes running on the same physical core (same or different logical core in SMT).\nThe RSB is dedicated to each logical core in the case of hyper-threading~.\nTable~\\ref{tbl:pred_share} shows whether the prediction unit can be trained when the training code and the victim are running in parallel in different settings.\nThe results are implementation-dependent and Table~\\ref{tbl:pred_share} shows the result from Intel processors.\nThe prediction units sometimes have many entries, and the attacker and the victim should use the same entry for mis-training.\nThe attacker and the victim will use the same entry only if they are using the same index. When the prediction unit is indexed by virtual address, the attacker can train the prediction unit from another address space using the same virtual address as the victim code. If only part of the virtual address is used as the index, which is shown as {\\tt f(virtual addr)} in Table~\\ref{tbl:pred_share}, the attacker can even train with an aliased virtual address, which maps to the same entry of the prediction unit as the victim address.\nThe RSB is not indexed by the address, rather it overflows when many nested calls are made,\nand this creates conflicts when there are more than $N$ nested calls, and will cause mis-prediction.\n\\begin{figure*}[t]\n\\includegraphics[width=4in]{gfx/volatile_channel.pdf}\n\\caption{\\small Steps for the sender and the receiver to transfer information through volatile covert channels. The yellow box shows the shared resource. The solid (dashed) arrow shows the shared resource is (is not) requested or used by the corresponding party.}\n \\label{fig:volatile_channel}\n\\end{figure*}", "cites": [1363, 1366], "cite_extract_rate": 0.25, "origin_cites_number": 8, "insight_result": {"type": "analytical", "scores": {"synthesis": 4.0, "critical": 3.0, "abstraction": 3.5}, "insight_level": "medium", "analysis": "The section synthesizes information from two relevant papers (Spectre and ret2spec) to explain how control flow prediction units like PHT, BTB, and RSB function and can be exploited. It integrates these ideas into a coherent explanation of shared and dedicated prediction resources in Intel processors. While it provides a clear analytical framework for understanding mis-training in speculative execution, it lacks deeper critical evaluation of the papers' limitations or broader implications, and the level of abstraction remains moderate rather than reaching meta-level insights."}}
{"id": "89e6daa1-889f-4d34-b58c-b5ee0a817d8c", "title": "Address Speculation:", "level": "subsubsection", "subsections": [], "parent_id": "cb4aac55-51a9-481a-98d8-e0bb0a27bc7b", "prefix_titles": [["title", "Survey of Transient Execution Attacks"], ["section", "Transient Execution"], ["subsection", "Required Sharing during Transient Execution"], ["subsubsection", "Address Speculation:"]], "content": "\\label{sec:Addr_spec_Intel}\nOne of the uses of address speculation is in the memory disambiguation to resolve read-after-write hazards, which are the data dependencies between instructions in out-of-order execution.\nIn Intel processors, there are two known uses of address speculation. First, loads are assumed not to conflict with earlier stores with unknown addresses, and speculatively store-to-load (STL) forwarding will not happen. When the address of a store is later resolved, the addresses of younger loads will be checked. And if store-to-load forwarding should have happened and data dependence has been violated, the loads will be flushed, and the new data is reloaded from the store, as shown in the attacks~. Second, for performance, when the address of a load {\\em partially} matches the address of a preceding store, the store buffer will forward the data of the store to the load speculatively,  even though the full addresses of the two may not match~. In the end, if there is mis-prediction, the load will be marked as faulty, flushed, and reloaded again.\nAnother use of address speculation is in conjunction with the line-fill buffer (LFB), which is the buffer storing cache-lines to be filled to the L1 cache. LFB may forward data speculatively without knowledge of the target address~.\nAddress speculation may also be used in other hardware structures in Intel processors, as indicated in ~.\nTo trigger address speculation, the availability of the address should be delayed to force the hardware to predict the address.\nOne way is to make the address calculation depends on some uncached data, as in Spectre V4~.\nAnother way is to use a newly mapped page, so that the physical address is available only after OS handles the page-in event, as in~. In an extreme case, the speculation can even be caused by a NULL pointer or an invalid address, and then the error is suppressed in the attacker code, as in attack~.\nIn STL, the entries are indexed by a function of physical addresses. In this case, the training code needs to share memory space with the victim to achieve an attack.", "cites": [1361, 7343], "cite_extract_rate": 0.4, "origin_cites_number": 5, "insight_result": {"type": "analytical", "scores": {"synthesis": 3.5, "critical": 2.5, "abstraction": 3.0}, "insight_level": "medium", "analysis": "The section synthesizes concepts from cited papers to explain how address speculation functions within Intel processors and how it can be exploited. It connects multiple mechanisms like STL forwarding, LFB behavior, and OS page-in events to transient execution attacks. While it offers some level of integration and abstraction by generalizing the role of address speculation, it lacks deeper critical analysis of the cited works' limitations or implications."}}
{"id": "5c358c86-0e6e-485e-ae28-1102c5f65ba7", "title": "Covert Channels", "level": "section", "subsections": ["72b61380-4422-41e8-af0a-9f5fcca3977e", "eb0110d7-3528-44a1-9dd3-225a482d73cf", "28338247-7cee-4052-9db4-47b1f3b14832", "9c3fc637-6097-4b4a-bd99-ad36006f6bd5", "a647d7a6-bcb3-4342-9dee-6192aa5c53c3", "6fd5bdd1-7aa1-4b25-a844-269b474f77be", "2ac728bb-46fc-492e-a83e-150f463359ec"], "parent_id": "2f4b0bae-709d-4d09-b856-92d94c793465", "prefix_titles": [["title", "Survey of Transient Execution Attacks"], ["section", "Covert Channels"]], "content": "\\label{sec:covert_channel}\nTransient execution enables the attacker to access the secret data transiently,\nand\na covert channel\\footnote{The channel is considered a covert channel, not a side channel~, because the attacker has \ncontrol over the disclosure gadget, which encodes the secret. }~ is required\nfor the attacker to eventually obtain the secret data in architectural states.\nThere is a distinction between {\\em conventional channels} where the encoding happens in software execution path,\nand {\\em transient execution channels} where the encoding phase is executed transiently.\nHere, we focus on covert channels that can be used in transient attacks -- these can also be used as conventional covert channels.\nThere are two parties in a covert channel: the sender and the receiver. \nIn the covert channels, the sender execution will change some micro-architectural state and the receiver will observe the change to extract information, e.g., by observe the execution time.\n \\begin{table*}[t]\n\\setlength{\\tabcolsep}{3pt}\n\\centering\n\\caption{\\small Known Covert Channels in Micro-architecture.}\n\\centering\n\\begin{threeparttable}\n\\small\n\\begin{tabular}{  l l | l l l l  | c C{0.8in} }\n & \\multirow{8}{1.3in}{\\bf Covert Channel Type} &\\multicolumn{4}{C{0.6in}|}{\\bf Level of Sharing}   & \\multirow{8}{0.6in}{\\bf Bandwidth} & \\multirow{8}{0.95in}{\\bf Required Time~Resolution of the Receiver (CPU cycles)} \\\\\n &  &\\parbox{0.1in}{\\rotatebox{90}{same thread}} &  \\parbox{0.1in}{\\rotatebox{90}{same core, different thread}}  &  \\parbox{0.1in}{\\rotatebox{90}{same chip, different core}} &  \\parbox{0.1in}{\\rotatebox{90}{same motherboard}}  & &  \\\\\n\\hline\n\\multirow{4}{0.6in}{{Volatile Covert Channels}} & Execution Ports~ &$\\boxtimes$ & $\\boxtimes$ &$\\Box$& $\\Box$& not given & 50 vs. 80\\\\\n& FP division unit~ &$\\boxtimes$ & $\\boxtimes$ &$\\Box$& $\\Box$ & $\\sim$70kB/s & 314 vs. 342\\\\\n& L1 Cache Ports~ &$\\boxtimes$ & $\\boxtimes$ &$\\Box$& $\\Box$ & not given & 36 vs. 48\\\\\n& Memory Bus~ &$\\boxtimes$ & $\\boxtimes$ & $\\boxtimes$& $\\boxtimes$  & $\\sim$700 B/s & 2500 vs. 8000\\\\\n\\hline\n\\multirow{10}{0.6in}{{Persistent Covert Channels}} \n& AVX2 unit~ &$\\boxtimes$ & $\\boxtimes$ &$\\Box$& $\\Box$ & $>$0.02B/s & 200 vs. 550\\\\\n& PHT~ &$\\boxtimes$ & $\\boxtimes$ &$\\Box$& $\\Box$ & not given & 65 vs. 90\\\\\n& BTB~ &$\\boxtimes$ & $\\boxtimes$ &$\\Box$& $\\Box$ & not given & 56 vs. 65\\\\\n& STL~ &$\\boxtimes$ & $\\Box$ &$\\Box$& $\\Box$ & not given & 30 vs. 300\\\\\n&TLB~ &$\\boxtimes$ & $\\boxtimes$ &$\\Box$& $\\Box$ &  $\\sim$5kB/s per set & 105 vs. 130\\tnote{a}\\\\\n&L1, L2 (tag, LRU)~ &$\\boxtimes$ & $\\boxtimes$ &$\\Box$& $\\Box$ & $\\sim$1MB/s per cache entry & 5 vs. 15\\tnote{b} \\\\\n&LLC (tag, LRU)~ &$\\Box$ & $\\Box$  &$\\boxtimes$ & $\\Box$ &  $\\sim$0.7MB/s per set & 500 vs. 800\\\\\n&Cache Coherence~  &$\\Box$ & $\\Box$  &$\\boxtimes$ & $\\boxtimes$ & $\\sim$1MB/s per cache entry & 100 vs. 250\\tnote{c}\\\\\n&Cache Directory~ &$\\Box$ & $\\Box$  &$\\boxtimes$ & $\\Box$ & $\\sim$0.2MB/s per slice & 40 vs. 400\\\\\n&DRAM row buffer~&$\\Box$ & $\\Box$ &$\\boxtimes$ & $\\boxtimes$ &  $\\sim$2MB/s per bank& 300 vs. 350\\\\\n\\hline\n\\end{tabular}\n\\begin{tablenotes}\n$\\boxtimes$ indicates that the attack is possible to leak the protected data; $\\Box$ indicates that the attack cannot leak the data.\n\\item[a] Depending on the level of TLB used, the required time resolution varies. The biggest one is shown.\n\\item[b] Shows the time resolution for covert channel use L1 cache.\n\\item[c] Depending on the setup, the required time resolution varies. The biggest one is shown.\n\\end{tablenotes}\n\\end{threeparttable}\n\\label{tbl:channel_share}\n\\end{table*}", "cites": [1363, 7344, 7346, 1360], "cite_extract_rate": 0.15384615384615385, "origin_cites_number": 26, "insight_result": {"type": "descriptive", "scores": {"synthesis": 2.5, "critical": 2.0, "abstraction": 2.0}, "insight_level": "low", "analysis": "The section provides a descriptive overview of covert channels in transient execution attacks and presents a table categorizing them based on cited works. While it organizes information systematically, it lacks deeper synthesis across the cited papers, critical evaluation of their methodologies or limitations, and broader abstraction or generalization to higher-level principles or trends in the field."}}
{"id": "28338247-7cee-4052-9db4-47b1f3b14832", "title": "Volatile Covert Channels", "level": "subsection", "subsections": [], "parent_id": "5c358c86-0e6e-485e-ae28-1102c5f65ba7", "prefix_titles": [["title", "Survey of Transient Execution Attacks"], ["section", "Covert Channels"], ["subsection", "Volatile Covert Channels"]], "content": "\\label{sec:volatile_channel}\nIn a \\textit{volatile covert channel}, there is contention for hardware between the sender and the receiver on the fly, and thus, the two should run concurrently, for example, as two hyper-threads in SMT processors, or running concurrently on two different cores. \nAnother scenario is that the sender and the receiver are two part of code in the same software thread that their instructions are scheduled to execute concurrently due to OoO~. \nAs shown in Figure~\\ref{fig:volatile_channel}, the receiver first measures the baseline execution time when the sender is not using the shared resource. Then, the sender causes contention on the shared resource or not depending on the message to be sent, while the receiver continues to measure the execution time. If the execution time increases, the receiver knows the sender is using the shared resource at the moment.\nExecution units, ports, and buses are shared between the hyper-threads running concurrently on the same physical core, and can be used for covert channels~.\n\\hl{There is also a covert channel leveraging the contention in the floating point division} unit~.\nL1 cache ports are also shared among hyper-threads.\nIn Intel processors, L1 cache is divided into banks, and each cache bank can only handle a single (or a limit number of) requests at a time. CacheBleed~ leverages the contention L1 cache bank to build a covert channel. Later, Intel resolved the cache bank conflicts issue with the Haswell generation.\nHowever, MemJam~ attack demonstrates that there is still a false dependency of memory read-after-write requests when the addresses are of the same L1 cache set and offset for newer generations of Intel processors. This false dependency can be used for a covert channel.\nAs shown in Table~\\ref{tbl:channel_share}, the covert channel in execution ports and L1 cache ports can lead to covert channels \\hl{within the same thread when the sender and the receiver code are executed in parallel due to OoO} and between hyper-threads in SMT setting.\nMemory bus serves memory requests to all the cores using the main memory.\nIn~, it is shown that the memory bus can act as a high-bandwidth covert channel medium, and covert channel attacks on various virtualized x86 systems are demonstrated.", "cites": [7344], "cite_extract_rate": 0.16666666666666666, "origin_cites_number": 6, "insight_result": {"type": "analytical", "scores": {"synthesis": 3.5, "critical": 3.0, "abstraction": 3.5}, "insight_level": "medium", "analysis": "The section provides an analytical overview of volatile covert channels by integrating examples from different hardware components and citing relevant attacks. It synthesizes multiple mechanisms (execution units, L1 cache, memory bus) and explains how they enable information leakage. While it includes some critical observations (e.g., unresolved false dependency in MemJam), it lacks deeper comparative analysis or evaluation of the strengths and weaknesses of the cited works. The abstraction is moderate, as it identifies shared patterns in contention-based communication but stops short of offering a novel, high-level framework."}}
{"id": "0f8b9c8b-4904-4e3a-b7a5-261d34e637e3", "title": "Occupancy-based Persistent Covert Channels", "level": "subsubsection", "subsections": [], "parent_id": "9c3fc637-6097-4b4a-bd99-ad36006f6bd5", "prefix_titles": [["title", "Survey of Transient Execution Attacks"], ["section", "Covert Channels"], ["subsection", "Persistent Covert Channels"], ["subsubsection", "Occupancy-based Persistent Covert Channels"]], "content": "To leverage occupancy-based covert channel, the user needs to occupy the states (e.g., registers, cache, or some entries) or data to affect the execution.\n\\begin{itemize}[itemindent=15pt,leftmargin=0pt,listparindent=\\parindent]\n\\item \\textit{Eviction-based Persistent Channels:}\nIn this channel, the sender and the receiver will compete and evict the other party to occupy some states to store their data or metadata to (de-)accelerate their execution. One example of the eviction-based channel is the Prime+Probe attack~. The receiver first occupies a cache set (i.e., primes).  Then, the sender may use the state for her data or not, depending on the message to be sent. And in the end, the receiver reads (i.e., probes) her data that were used to occupy the cache set in the first step to see whether those data are still in the cache by measuring the timing, as shown in the first row of Figure~\\ref{fig:persistent_channel}. Other examples of the eviction-based channel are cache Evict+Time attack~, the covert channel in DRAM row buffer~.\n\\begin{figure*}[t]\n\\includegraphics[width=4.3in]{gfx/persistent_channel.pdf}\n\\caption{\\small Steps for the sender and the receiver to transfer information through different types of persistent covert channels.}\n \\label{fig:persistent_channel}\n\\end{figure*} \nAnother possible contention is that the sender needs to use the same piece of data (e.g., need exclusive access to the data for write), and thus, the receiver's copy of data can be invalidated.\nSome state is used for tracking the relationship of data in different components, which can cause the data in one component to be invalidated.\nFor example, cache coherency policy can invalidate a cache line in a remote cache, and thus, it results in a covert channel between threads on different cores on the same processor chip~.\nCache directory keeps the tags and cache coherence state of cache lines in the lower levels of cache in a non-inclusive cache hierarchy and can cause eviction of a cache line in the lower cache level (a remote cache relative to the sender) to build a covert channel~.\n\\item \\textit{Reuse-based Persistent Channels:}\nIn this channel, the sender and the receiver will share some data or metadata, and if the data is stored in the shared state, it could (de-)accelerate both of their execution. The cache Flush+Reload attack~ transfers information by {\\em reusing} the same data in the cache. The receiver first cleans the cache state. Then, the sender loads the shared data or not. And in the end, the receiver measures the execution time of loading the shared data, as in Figure~\\ref{fig:persistent_channel}. If the sender loads the shared data in the second step, the receiver will observer faster timing compared to the case when the sender does not load the shared data.\nThere are other reuse-based attacks, such as Cache Collision attack~ and the cache Flush+Flush attack~.\n\\hl{Prediction units can also be leveraged for such covert channels due to a longer latency for mis-prediction. \nFor example, PHT}~, BTB~, and STL~ have been demonstrated to be usable for constructing covert channels. For example, when sharing BTB, the sender and the receiver use the same indirect jump source, ensuring the same BTB entry is used. If the receiver has the same destination address as the sender, the BTB will make a correct prediction resulting in a faster jump.\n\\end{itemize}", "cites": [7346], "cite_extract_rate": 0.05263157894736842, "origin_cites_number": 19, "insight_result": {"type": "descriptive", "scores": {"synthesis": 2.5, "critical": 2.0, "abstraction": 2.5}, "insight_level": "medium", "analysis": "The section describes occupancy-based persistent covert channels by categorizing them into eviction-based and reuse-based types, and briefly mentions associated attacks and mechanisms. It integrates some ideas from different works but lacks deeper synthesis or novel framework creation. There is minimal critical analysis of the cited papers, and the abstraction remains limited to the technical description of mechanisms rather than broader architectural or security principles."}}
{"id": "8e4181b0-82a2-4c27-ae7b-f904537133cc", "title": "Encode-based Persistent Covert Channels", "level": "subsubsection", "subsections": [], "parent_id": "9c3fc637-6097-4b4a-bd99-ad36006f6bd5", "prefix_titles": [["title", "Survey of Transient Execution Attacks"], ["section", "Covert Channels"], ["subsection", "Persistent Covert Channels"], ["subsubsection", "Encode-based Persistent Covert Channels"]], "content": "In encode-based persistent covert channels,  the sender and the receiver can both directly change and probe the shared state. One example of such a channel is the AVX channel~. There are two AVX2 unit states: power-off and power-on.  To save power, the CPU can power down the upper half of the AVX2 unit by default. In step 2, if the sender then uses the AVX2 unit, it will be power-on the unit for at least 1 ms. In step 3, the receiver can measure whether the AVX2 unit is power-on by measuring the time of using AVXs unit. In this way, the sender encodes the message into the state of the AVX2 unit, as shown in Figure~\\ref{fig:persistent_channel}.\nOther examples are the covert channels leveraging cache LRU states~.", "cites": [1360], "cite_extract_rate": 0.25, "origin_cites_number": 4, "insight_result": {"type": "descriptive", "scores": {"synthesis": 2.0, "critical": 1.5, "abstraction": 2.0}, "insight_level": "low", "analysis": "The section provides a basic description of encode-based persistent covert channels using the AVX2 unit as an example. It draws from a single cited paper to explain the mechanism but does not integrate additional sources or synthesize broader concepts. There is minimal critical analysis or abstraction to identify patterns or principles beyond the specific example."}}
{"id": "ccfa843e-cbae-4445-b4cf-783a75c1f4e0", "title": "Existing Transient Execution Attacks", "level": "section", "subsections": ["6b17c85b-65b5-445b-a8d9-e6b9169eb092", "22a45cfa-75c7-4a2f-93ed-a85f5f76ba78", "42dca5b4-9762-48f1-a5a9-ead5b56aa9c7"], "parent_id": "2f4b0bae-709d-4d09-b856-92d94c793465", "prefix_titles": [["title", "Survey of Transient Execution Attacks"], ["section", "Existing Transient Execution Attacks"]], "content": "\\label{sec:transient_attacks}\nThe transient execution attacks contain two parts: triggering transient execution to obtain data \nthat is otherwise not accessible (discussed in Section~\\ref{sec:transient_exe}) \nand transferring the data via a covert channel (discussed in Section~\\ref{sec:covert_channel}).\nIf the victim executes transiently, the victim will encode the secret into the channel, and the behavior cannot be analyzed from \nthe software semantics without a hardware model of prediction.\nIf the attacker executes transiently, the micro-architecture propagates data that is not allowed to propagate at the ISA level (propagation is not visible at ISA level, but can be reconstructed through cover channels which observe the changes in micro-architecture).\nTo formally model and detect the behavior, a new micro-architectural model, including the transient behavior, should be used~.", "cites": [1368, 1369, 1367], "cite_extract_rate": 0.75, "origin_cites_number": 4, "insight_result": {"type": "analytical", "scores": {"synthesis": 3.0, "critical": 2.5, "abstraction": 3.0}, "insight_level": "medium", "analysis": "The section provides an analytical overview of transient execution attacks, referencing concepts from the cited papers such as the need for micro-architectural models and the role of covert channels. It synthesizes the two main components of such attacks but does not deeply integrate or contrast the specific contributions of each paper. While it hints at broader implications (e.g., the need for hardware-software co-design), the critical evaluation of these works or their limitations is minimal."}}
{"id": "6b17c85b-65b5-445b-a8d9-e6b9169eb092", "title": "Existing Transient Execution Attacks Types", "level": "subsection", "subsections": [], "parent_id": "ccfa843e-cbae-4445-b4cf-783a75c1f4e0", "prefix_titles": [["title", "Survey of Transient Execution Attacks"], ["section", "Existing Transient Execution Attacks"], ["subsection", "Existing Transient Execution Attacks Types"]], "content": "\\begin{table*}[t]\n\\centering\n\\caption{\\small  Transient Execution Attacks Types.}\n\\begin{threeparttable}\n\\small\n\\begin{tabular}{  l | l l l l l l }\n& \\multicolumn{6}{c}{\\bf Cause of Transient Execution}\\\\\n \\parbox{0.9in}{\\bf Covert Channel} &\\parbox{0.4in}{\\rotatebox{0}{PHT}} &  \\parbox{0.4in}{\\rotatebox{0}{BTB}}  &  \\parbox{0.4in}{\\rotatebox{0}{RSB}} &  \\parbox{0.4in}{\\rotatebox{0}{STL}}  & \\parbox{0.4in}{\\rotatebox{0}{LFB}} & \\parbox{0.5in}{\\rotatebox{0}{Exception}}  \\\\\n\\hline\n Execution Ports &$\\Box$ & &$\\Box$&$\\Box$&$\\Box$ &$\\Box$\\\\\n L1 Cache Ports &$\\Box$ &$\\Box$&$\\Box$&$\\Box$ &$\\Box$&$\\Box$\\\\\n Memory Bus &$\\Box$ &$\\Box$&$\\Box$&$\\Box$ &$\\Box$&$\\Box$\\\\\n AVX2 unit && $\\Box$ &$\\Box$ &$\\Box$&$\\Box$&$\\Box$ \\\\\n FP div unit  && $\\Box$ &$\\Box$ &$\\Box$&$\\Box$& \\\\\nTLB & $\\Box$ &$\\Box$&$\\Box$&$\\Box$ &$\\Box$ &$\\Box$\\\\\nL1, L2 (tag, LRU) &&  & & & &\\\\\nLLC (tag, LRU) &$\\Box$ &$\\Box$&$\\Box$&$\\Box$ &$\\Box$ &$\\Box$\\\\\nCache Coherence  & &$\\Box$ &$\\Box$&$\\Box$&$\\Box$ &\\\\\nCache Directory &$\\Box$ &$\\Box$&$\\Box$&$\\Box$ &$\\Box$ &$\\Box$\\\\\nDRAM row buffer &$\\Box$ &$\\Box$&$\\Box$&$\\Box$ &$\\Box$ &$\\Box$ \\\\\nOther Channel &$\\Box$ &$\\Box$&$\\Box$&$\\Box$ &$\\Box$ &$\\Box$\\\\\n\\hline\n\\end{tabular}\n\\begin{tablenotes}\n$\\Box$ shows attacks that are possible but not demonstrated yet.\n\\end{tablenotes}\n\\end{threeparttable}\n\\label{tbl:attack_demo}\n\\end{table*}\nTo launch an attack, the attacker needs a way to cause transient execution of the victim or herself and a covert channel.\nTable~\\ref{tbl:attack_demo} shows the attacks that are demonstrated in the publications. For demonstrating different speculation primitives, researchers usually use the covert channel in caches (row L1, L2 in Table~\\ref{tbl:attack_demo}). This is because the cache Flush+Reload covert channel is simple and efficient.\nFor demonstrating different covert channels used in transient execution attacks, researchers usually use PHT (Spectre V1).  This is because Spectre V1 is easy to demonstrate.\nNote that every entry in the table can become an attack.\nFor mitigations, each entry of the table should be mitigated, either mitigate all the covert channels or prevent accessing the secret data in transient execution.", "cites": [7343, 1362, 1366, 1361, 7347, 1363, 7344, 7345, 1360], "cite_extract_rate": 0.47368421052631576, "origin_cites_number": 19, "insight_result": {"type": "descriptive", "scores": {"synthesis": 2.5, "critical": 2.0, "abstraction": 2.0}, "insight_level": "low", "analysis": "The section primarily describes the various types of transient execution attacks by organizing them into a table listing the causes of transient execution and possible covert channels. It makes minimal synthesis of ideas across the cited works, only noting general trends like the use of cache-based channels for simplicity. There is little critical evaluation of the cited works, and no abstraction to broader principles or frameworks."}}
{"id": "42dca5b4-9762-48f1-a5a9-ead5b56aa9c7", "title": "Attacks on Different Commercial Platforms", "level": "subsection", "subsections": [], "parent_id": "ccfa843e-cbae-4445-b4cf-783a75c1f4e0", "prefix_titles": [["title", "Survey of Transient Execution Attacks"], ["section", "Existing Transient Execution Attacks"], ["subsection", "Attacks on Different Commercial Platforms"]], "content": "\\hl{Most of the existing studies focus on Intel processors, Table}~\\ref{tbl:commercial}\\hl{ lists the known attacks on processors by different venders, such as} AMD~, Arm~, RISC-V~\\hl{. As shown in the table, Spectre-type attacks using branch prediction are found on all the platforms, this is because branch speculation is fundamental in modern processors. Other transient execution depends on the micro-architecture implementation of speculation units, and show different results on different platforms.}\n\\begin{table*}[t]\n\\centering\n\\caption{\\small \\hl{Known Transient Execution Attacks on Different Platforms.}}\n\\begin{threeparttable}\n\\centering\n\\small\n\\begin{tabular}{ l l| c c c c c c c  }\n \\multicolumn{2}{C{18em}|}{\\bf Cause of Transient Execution}  &  {\\bf Intel} &  {\\bf AMD~} & {\\bf Arm~} &  {\\bf RISC-V}  \\\\\n\\hline\n\\multirow{3}{6em}{{Control Flow}} \n& PHT (V1)& $\\boxtimes$ & $\\boxtimes$ &$\\boxtimes$ & $\\boxtimes$ \\\\\n& BTB (V2)&$\\boxtimes$ & $\\boxtimes$ &$\\boxtimes$ &$\\boxtimes$ \\\\\n& RSB (V5)&$\\boxtimes$ & $\\Box$\\ &$\\boxtimes$  & $\\Box$\\\\\n\\hline\n\\multirow{2}{10em}{{Address Speculation}} \n& STL (V4,MDS) &$\\boxtimes$ &$\\Box$  &$\\boxtimes$  &$\\Box$\\ \\\\\n& LFB (MDS)&$\\boxtimes$  &$\\Box$  &$\\Box$ &$\\boxtimes$ \\\\\n\\hline\n\\multirow{6}{4em}{{Exception}} \n&  PF-US (V3) &$\\boxtimes$&$\\Box$ & $\\boxtimes$ & $\\Box$\\\\\n& PF-P (L1TF) &$\\boxtimes$ &$\\Box$  &$\\Box$ &$\\Box$  \\\\\n& PF-RW (V1.2) &$\\boxtimes$ &$\\Box$ &$\\boxtimes$ &$\\Box$  \\\\\n& NM (LazyFP)  &$\\boxtimes$ &$\\Box$ &$\\Box$ &$\\Box$  \\\\\n& GP (V3a) &$\\boxtimes$&$\\Box$ &$\\boxtimes$  &$\\Box$  \\\\\n& Other & $\\boxtimes$&$\\boxtimes$ &$\\boxtimes$  &$\\Box$\\\\\n\\hline\n\\end{tabular}\n\\begin{tablenotes}\n$\\boxtimes$ indicates that an attack of the type on the platform; $\\Box$ indicates that there is no known attack.\n\\end{tablenotes}\n\\end{threeparttable}\n\\label{tbl:commercial}\n\\end{table*}", "cites": [1365], "cite_extract_rate": 0.25, "origin_cites_number": 4, "insight_result": {"type": "comparative", "scores": {"synthesis": 3.0, "critical": 2.5, "abstraction": 3.0}, "insight_level": "medium", "analysis": "The section provides a comparative overview of transient execution attacks across different commercial platforms using a table, which synthesizes the data from the cited work. It makes basic connections by categorizing attacks based on their causes and highlighting platform-specific differences. However, it lacks deeper critical analysis or evaluation of the cited papers and focuses more on description than on deriving broader principles or insights."}}
{"id": "2fa00822-ddfc-46d2-883a-0da7b331ff92", "title": "Mitigations of Spectre-type Attacks in Micro-architecture Design", "level": "section", "subsections": ["f6f67ddd-b35f-4518-bfd6-ee749ee08553", "20ee94ca-b37a-49db-97bb-981acb8d805e"], "parent_id": "2f4b0bae-709d-4d09-b856-92d94c793465", "prefix_titles": [["title", "Survey of Transient Execution Attacks"], ["section", "Mitigations of Spectre-type Attacks in Micro-architecture Design"]], "content": "\\label{sec:mitigations}\nIn this section, we focus on micro-architectural mitigations to attacks that occur when the victim executes transiently under wrong control flow prediction. \n\\hl{As shown in Table}~\\ref{tbl:commercial}\\hl{, attacks that leveraging control flow prediction are more fundamental and affect all modern computer architectures.\nAttacks that leveraging address speculation and exceptions are implementation-dependent, and we consider them as implementation bugs. They can be fixed, although the performance penalty is unknown now.}\nWe focus on possible future micro-architecture designs that are safe against control flow prediction. Thus, software mitigation schemes, such as~, \\hl{and software vulnerability detection schemes}~ are not discussed in detail.", "cites": [1372, 1371, 1370], "cite_extract_rate": 0.5, "origin_cites_number": 6, "insight_result": {"type": "descriptive", "scores": {"synthesis": 2.0, "critical": 2.0, "abstraction": 2.0}, "insight_level": "low", "analysis": "The section provides a basic description of the focus on micro-architectural mitigations for Spectre-type attacks, with limited synthesis of the cited papers. It mentions the relevance of speculation exposure, data dependencies, and static analysis but does not connect these concepts into a broader narrative or framework. Critical analysis is minimal, with no evaluation of strengths, weaknesses, or trade-offs between the approaches. The abstraction level is low as it does not move beyond describing the individual techniques to present overarching principles or patterns."}}
{"id": "0e7f79e9-2f26-4a74-a9c3-210855a1024c", "title": "Mitigating the Trigger of Transient Execution", "level": "subsubsection", "subsections": [], "parent_id": "f6f67ddd-b35f-4518-bfd6-ee749ee08553", "prefix_titles": [["title", "Survey of Transient Execution Attacks"], ["section", "Mitigations of Spectre-type Attacks in Micro-architecture Design"], ["subsection", "Mitigating Transient Execution"], ["subsubsection", "Mitigating the Trigger of Transient Execution"]], "content": "To mitigate Spectre-type attacks, one solution is to limit the attackers' ability to mis-train the prediction units to prevent the disclosure gadget to be executed transiently (the first metric in Section~\\ref{sec:transient_metric}). The prediction units (e.g., PHT, BTB, RSB, STL) should not be shared among different users. This can be achieved by static partition for concurrent users and flush the state during context switches.\nFor example, there are ISA extensions for controlling and stopping indirect branch predictions~. In~, a decode-level branch predictor isolation technique is proposed, where a special micro-op that clears the branch predictor states will be executed when the security domain switches. In~, it is proposed to use thread-private random number to encode the branch prediction table, to build isolation between threads in the branch predictor.\nHowever, for both proposals, if the attacker can train the prediction unit by executing victim code with certain input (e.g., always provide valid input in Spectre V1), isolation is not enough. \nThere is also mitigation in software to stop speculation by making the potential secret data depends on the result of the branch condition leveraging data dependency, e.g., masking the data with the branch condition~, because current processors do not speculate on data.\nHowever, this solution requires to identify all control flow dependency and all disclosure gadgets, to figure out all possible control flow that could lead to the execution of the disclosure gadgets, and to patch each of them. \nIt is a challenge to identify all (current and future) disclosure gadgets, because disclosure gadgets may vary due to the encoding to different covert channels, and formal methods that model the micro-architecture behavior are required~.", "cites": [1371, 1368, 1367, 1373], "cite_extract_rate": 0.5, "origin_cites_number": 8, "insight_result": {"type": "analytical", "scores": {"synthesis": 3.5, "critical": 3.0, "abstraction": 3.0}, "insight_level": "medium", "analysis": "The section synthesizes multiple cited papers by discussing different approaches to isolating branch predictors and preventing speculation. It offers some critical analysis by pointing out the limitations of isolation mechanisms if attackers can still train the prediction units. However, the abstraction is limited to the context of Spectre-type attacks and does not generalize to broader patterns or principles in speculative execution security."}}
{"id": "f4e1eece-7f34-4cb1-8a01-f6d4d123eb1a", "title": "Mitigating Transient Execution of Disclosure Gadget", "level": "subsubsection", "subsections": [], "parent_id": "f6f67ddd-b35f-4518-bfd6-ee749ee08553", "prefix_titles": [["title", "Survey of Transient Execution Attacks"], ["section", "Mitigations of Spectre-type Attacks in Micro-architecture Design"], ["subsection", "Mitigating Transient Execution"], ["subsubsection", "Mitigating Transient Execution of Disclosure Gadget"]], "content": "To mitigate leak of secret during the transient execution attacks, one way is to prevent the transient execution of the disclosure gadget, i.e., to stop loading of secrets in transient execution or stop propagating the secret to younger instructions in the disclosure gadget transiently.\nFor Meltdown-type and MDS-type attacks, it means to stop propagating secret data to the younger instructions. \nFor Spectre-type attacks, however, the logic may not know which data is secret. \nTo mitigate the attacks, secret data should be tagged with metadata as in secure architecture designs, which will be discussed in Section~\\ref{sec:sec_arch}.\nAnother solution is that data cannot be propagated speculatively, and thus, cannot be send to covert channels speculatively, which can potentially prevent transient execution attacks with any covert channel.\nIn {\\em Context-Sensitive Fencing}~, fences will be injected at decoder-level to stop speculative data propagation if there are potential Spectre attacks.\nIn {\\em NDA}~, a set of propagation policies are designed for defending the attacks leveraging different types of transient executions (for example, transient execution due to branch prediction or all transient execution), showing the trade-off between security and performance.\nSimilarly, in {\\em SpecShield}~, different propagation policies are designed and evaluated.\nIn {\\em Conditional Speculation}~,  the authors propose a defense scheme targeting covert channels in the memory system and propose an architecture where data cannot be transiently propagated to instructions that lead to changes in memory system showing $13\\%$ performance overhead. To reduce performance overhead of the defense, they further change the design to only target Flush+Reload cache side channels, resulting performance overhead of $7\\%$.\nFurthermore, in {\\em STT}~, a dynamic information flow tracking based micro-architecture is proposed to stop the propagation of speculative data to covert channels but reduce the performance overhead by waking up instructions as early as possible.\n\\hl{Speculative data-oblivious (SDO) execution}~\\hl{ is based on STT. To reduce performance overhead, SDO introduces new predictions that do not depend on operands (holding data potentially depending on speculative data). Specifically, speculative data-oblivious loads are designed to allow safe speculative load. }\nThe overhead to defend Spectre-like attacks is moderate, e.g., $7.7\\%$ in  {\\em Context-Sensitive Fencing}~, $21\\%$ reported in {\\em SpecShield}~,  $20\\sim51\\%$ ($113\\%$ for defending all transient execution attacks) reported in {\\em NDA}~, and $8.5\\%$ for branch speculation ($14.5\\%$ for all transient execution) in {\\em STT}~, $4.19\\%$ for branch speculation ($10.05\\%$ for all transient execution) in {\\em STT+SDO}~.\n\\begin{table*}[t]\n\\centering\n\\caption{\\small Comparison of Different Mitigation Schemes in Micro-architecture.}\n\\begin{threeparttable}\n\\small\n\\begin{tabular}{   | p{2.2in} | p{3in} |  }\n\\hline\n\\textbf{Mitigation Schemes} & \\textbf{Performance Overhead} \\\\\n\\hline\nFence after each branch & $88\\%$~ \\\\\n\\hline\nStop propagating all data & $30$--$55\\%$~; $21\\%$~; $20$--$51\\%$~; $8.5\\%$~; $4.19\\%$~  \\\\\nStop propagating all data to cache changes& $7.7\\%$~, $13\\%$~\\\\\nStop propagating all data to Flush+Reload &$7\\%$~\\\\\n\\hline\nStop propagating all tagged secret data& $71\\%$ for security-critical applications, $<1\\%$~for real-world workloads~\\\\\n\\hline\nPartitioned cache & $1$--$15\\%$~ \\\\\n\\hline\nStop (Undo) speculative change in caches &7.6\\%~; 11\\%~; 4\\%~;  5.1\\%~; 8.3\\%~\\\\\n\\hline\n\\end{tabular}\n\\begin{tablenotes}\n\\end{tablenotes}\n\\end{threeparttable}\n\\label{tbl:mitigation}\n\\end{table*}\nThere should be a large enough speculative window to let the disclosure gadget execute transiently for the attack to happen. The micro-architecture may be able to limit the speculation window size to prevent the encoding to the covert channel (the fourth metric in Section~\\ref{sec:transient_metric}). However, the disclosure gadget can be very small that only contains two loads from L1~, which is only about 20 cycles in total. Detecting a malicious windowing gadget accurately can be~challenging.", "cites": [1374], "cite_extract_rate": 0.0625, "origin_cites_number": 16, "insight_result": {"type": "comparative", "scores": {"synthesis": 3.0, "critical": 2.5, "abstraction": 3.0}, "insight_level": "medium", "analysis": "The section synthesizes several mitigation approaches for Spectre-type attacks by categorizing them based on their method of preventing speculative data propagation. It provides a comparative view of performance overheads but lacks deeper critical evaluation of the trade-offs or limitations of each approach. While it identifies general patterns (e.g., varying overhead depending on the scope of mitigation), it stops short of offering meta-level insights or a novel framework."}}
{"id": "a17caebb-f56c-431c-973a-ab341ba3c62f", "title": "Mitigations in Secure Architectures", "level": "subsubsection", "subsections": [], "parent_id": "f6f67ddd-b35f-4518-bfd6-ee749ee08553", "prefix_titles": [["title", "Survey of Transient Execution Attacks"], ["section", "Mitigations of Spectre-type Attacks in Micro-architecture Design"], ["subsection", "Mitigating Transient Execution"], ["subsubsection", "Mitigations in Secure Architectures"]], "content": "\\label{sec:sec_arch}\nSecure architectures are designed to protect the confidentiality (or integrity) of certain data or code.\nThus, secure architectures usually come with ISA extensions to identify the data or code to be protected, e.g., secret data region, and micro-architecture designs to isolate the data and code to be protected~.\nWith knowledge about the data to be protected, hardware can further stop propagating secret data during speculation.\nThe hardware can identify data that is depended on the secret with taint checking, as proposed in~, and forbid tainted data to have micro-architectural side effects, or flush\nall the states on exit from the protected domain, to defend against persistent covert channels, and disable SMT to defend volatile covert channels.\nThe overhead of such mitigation depends on the size of secret data to be protected. For example, as reported in {\\em ConTExT}~, the overhead is $71.14\\%$ for OpenSSL RSA encryption and less than $1\\%$ for real-world workloads.\nSimilar overhead is reported in {\\em SpectreGuard}~.\nIntel also proposed a new memory type, named speculative-access protected memory (SAPM)~. Any access to SAPM region will cause instruction-level serialization and speculative execution beyond the SAPM-accessing instruction will be stopped until the retirement of that instruction.", "cites": [1363], "cite_extract_rate": 0.125, "origin_cites_number": 8, "insight_result": {"type": "descriptive", "scores": {"synthesis": 2.5, "critical": 2.0, "abstraction": 2.3}, "insight_level": "low", "analysis": "The section provides a factual summary of secure architectural mitigations, including examples like taint checking, state flushing, and SMT disabling. While it mentions a couple of works (ConTExT, SpectreGuard) and a hardware feature (SAPM), it does not effectively synthesize or integrate these ideas into a broader framework. There is minimal critical analysis or evaluation of trade-offs and limitations, and the abstraction level remains low with no clear meta-insights or overarching design principles identified."}}
{"id": "20ee94ca-b37a-49db-97bb-981acb8d805e", "title": "Mitigating Covert Channels", "level": "subsection", "subsections": ["48e84ca1-f1d3-44d6-aca3-0f6616dc7be0"], "parent_id": "2fa00822-ddfc-46d2-883a-0da7b331ff92", "prefix_titles": [["title", "Survey of Transient Execution Attacks"], ["section", "Mitigations of Spectre-type Attacks in Micro-architecture Design"], ["subsection", "Mitigating Covert Channels"]], "content": "To limit the covert channels, one way is to isolate all the hardware across the sender and receiver of the channel, so the change cannot be observable to the receiver. However, this is not always possible, e.g., in some attacks, the attacker is both the sender and the receiver of the channel.\nAnother mitigation is to eliminate the sender of the covert channel in transient execution.\nFor volatile covert channels, the mitigation is challenging.\nFor permanent covert channels, there should not be speculative change to any micro-architectural states or any micro-architectural state changes should be rolled back when the pipeline is squashed. \nCovert channels in memory systems, such as caches and TLBs, are most commonly used. Hence, most of the existing mitigations focus on cache and TLB side channels.\n{\\em InvisiSpec}~ proposed the concept of ``visibility point\" of a load, which indicates the time when a load is safe to cause micro-architecture state changes that are visible to attackers. Before the visibility point, a load may be squashed, and should not cause any micro-architecture state changes visible to the attackers. To reduce performance overhead, a ``speculative buffer\" is used to temporarily cache the load, without modifications in the local cache. After the ``visibility point\", the data will be fetched into the cache. For cache coherency, a new coherency policy is designed such that the data will be validated when stale data is potentially fetched. The gem5~ simulation results show a 7.6\\% performance loss for SPEC 2006 benchmark~.\nSimilarly, SafeSpec~ proposed to add ``shadow buffers\" to caches and TLBs, so that transient changes in the caches and TLBs does not happen. \nIn {\\em Muontrap}~\\hl{, ``filter cache\" (L0 cache) is added to each physical thread to hold speculative data. \nThe proposed filter cache only holds data that is in Shared state, so it will not change the timing of accessing other caches. If the shared state in L0 is not possible without causing the cache line in another cache to change state form Modified or Exclusive state, the access will be delayed until it is at the head of ROB.\nThe cache line will be written through to L1 when the corresponding instruction commits.\nDifferent from the buffers in InvisiSpec}~ and SafeSpec~\\hl{, the filter cache is a real cache that is cleared upon a context switch, syscall, or when the execution change security boundaries (e.g., explicit flush when exiting sandbox) to ensure isolation between security boundaries. Muontrap results in a 4\\% slowdown for SPEC 2006.}\n{\\em CleanupSpec}~ proposed to use a combination of undoing the speculative changes and secure cache designs. When mis-speculation is detected and the pipeline is squashed, the changes to the L1 cache are rolled back. For tracking the speculative changes in caches, 1Kbyte storage overhead is introduced.\nTo prevent the cross-core or multi-thread covert channel, partitioned L1 with random replacement policy and randomized L2/LLC are used.\nBecause only a small portion of transient executions results in mis-speculations, the method shows an average slowdown of 5.1\\%.\n{\\em ReversiSpec}~ \\hl{proposed a comprehensive cache coherence protocol considering speculative cache accesses. The cache coherence protocol proposed an interface including three operations: 1) speculative load, 2) merge when a speculative load is safe, 3) purge when a speculative load is squashed. Compared to InvisiSpec}~\\hl{, the speculative buffer only stores data when the data is not in the cache, and thus,\nless data movement will occur when a load is safe (merge). Compared to CleanupSpec}~\\hl{,  purge is fast as not all the changes have propagated in to cache. The performance overhead is 8.3\\%.}\nMoreover, accessing speculative loads that hit in L1 cache will not cause side effects (except LRU state updates) in the memory system. Therefore, only allowing speculative L1 hits can mitigate transient execution attacks using covert channels (other than LRU) in the memory system. \nIn {\\em Selective Delay}~, to improve performance, for a speculative load that miss in L1, value prediction is used. The load will fetch from deeper layers in the memory hierarchy until the load is not speculative. In their solution, 11\\% performance overhead is shown.\nMeanwhile, many secure cache architectures are proposed to use randomization to mitigate the cache covert channels in general (not only the transient execution attacks).\nFor example, {\\em Random Fill cache}~ decouples the load and the data that is filled into the cache, and thus, the cache state will no longer reflect the sender's memory access pattern.\n{\\em Random Permutation (RP) cache}~, {\\em Newcache cache}~, {\\em CEASER cache}~, and {\\em ScatterCache}~ randomize memory-to-cache-set mapping to mitigate contention-based occupancy-based covert channels in the cache.\n{\\em Non Deterministic cache}~ randomizes cache access delay and de-couple the\nrelation between cache block access and cache access timing.\nSecure TLBs~ are also proposed to mitigate covert channels in TLBs.\nBut again, all the possible covert channels need to be mitigated to fully mitigate transient execution attacks.\nFurther, {\\em Cyclone}~ proposed a micro-architecture to detect cache information leaks across security domains.\nAnother mitigation is to degrade the quality of the channel or even make the channel unusable for a practical attack.\nFor example, many timing covert channels require the receiver to have a fine-grained clock to observe the channel (the second metric in Section~\\ref{sec:CC_metric}). Limiting the receiver's observation will reduce the bandwidth or even mitigate the covert channel~.  Noise can also be added to the channel to reduce the bandwidth (the third metric in Section~\\ref{sec:CC_metric}).\nHowever, the above mitigations only cover covert channels in memory systems.\nTo mitigate other covert channels, there are the following challenges:\n1. Identify all possible covert channels in micro-architecture, including future covert channels.\nFormal methods are required in this process. For example, information flow tracking, such as methods in~, can be used to analyze the hardware components, where the data of transient execution could flow to. Then, analyze if each of the components could result in a permanent or transient covert channel.\n2. Mitigate each of the possible covert channels.", "cites": [1374, 1364], "cite_extract_rate": 0.09090909090909091, "origin_cites_number": 22, "insight_result": {"type": "analytical", "scores": {"synthesis": 4.2, "critical": 3.8, "abstraction": 4.0}, "insight_level": "high", "analysis": "The section effectively synthesizes several mitigation techniques for covert channels and connects them to form a coherent narrative. It includes critical evaluation by comparing performance overhead and design differences between approaches (e.g., InvisiSpec, SafeSpec, MuonTrap, CleanupSpec, ReversiSpec). The discussion also abstracts to broader principles, such as the use of formal methods to identify all possible covert channels and the generalization of secure cache and TLB designs."}}
{"id": "48e84ca1-f1d3-44d6-aca3-0f6616dc7be0", "title": "Mitigations in Secure Architectures", "level": "subsubsection", "subsections": [], "parent_id": "20ee94ca-b37a-49db-97bb-981acb8d805e", "prefix_titles": [["title", "Survey of Transient Execution Attacks"], ["section", "Mitigations of Spectre-type Attacks in Micro-architecture Design"], ["subsection", "Mitigating Covert Channels"], ["subsubsection", "Mitigations in Secure Architectures"]], "content": "\\label{sec:sec_arch_covert_channel}\nWith clearly defined security domain, isolation can be designed to mitigate not only transient covert channels and also conventional covert channels.\nFor example, to defend cache covert channels, a number of partitioned caches to different security domains are proposed, either statically~ or dynamically~. With partition, shared resource no longer exists between the sender and the receiver, and the receiver cannot observe secret dependent behavior to decode the secret. \nThe above proposal assumes the hardware is isolated for each security domain. However, there is also a scenario where software outside the security domain may use the same hardware after a context switch.\nIn {\\em Mi6} processor~, caches and ports partitioning are used to isolate software on different cores. Further, when there is a context switch, a security monitor flushes the architecture and micro-architecture states, which holds the information of in-flight speculation from the previously executing program. To protect the security monitor, speculation is not used in the execution of the security monitor. In OPTIMUS~\\hl{, a dynamic partitioning scheme in the granularity of core is proposed to achieve both security and high performance.}\n\\label{sec:related_attacks}\nAnother category of attacks that can be mistaken with the transient execution attacks is the covert channel attacks leveraging transient execution.\nDifferent from the transient execution attacks where the goal of the attacker is to compromise the confidentially of victim's secret,  these attacks have the goal to build  novel covert channels leveraging the hardware units for transient execution~, such as the branch prediction unit, STL, etc.\nModern computer architectures gain performance benefits from transient execution.\nCorrect predictions result in useful transient execution results and make the execution faster. When a wrong prediction is made, the results of transient execution will be discarded and sometimes cause a small penalty.\nTherefore, there is a time difference in the execution due to transient execution, and a timing-based covert channel can be built.\nAs shown in Table~\\ref{tbl:pred_share}, prediction units are shared between different users. The sender can train a prediction unit, and then the receiver can observe different prediction results.\nReal covert channel attacks have been demonstrated by leveraging the prediction units, such as {\\em Branchscope} attack, which uses PHT~,  {\\em Jump over ASLR}, which uses BTB~, and {\\em Spoiler} attack which uses STL~.\nOther than building covert channel across processes and SGX enclave~,\nthese attacks also break KASLR (Kernel address space layout randomization)~ and\nleak the physical address mapping~.", "cites": [1375, 7346], "cite_extract_rate": 0.10526315789473684, "origin_cites_number": 19, "insight_result": {"type": "analytical", "scores": {"synthesis": 3.5, "critical": 2.5, "abstraction": 3.0}, "insight_level": "medium", "analysis": "The section synthesizes concepts from two cited papers to explain how secure architectures can mitigate covert channels, particularly through cache and prediction unit partitioning. It provides an analytical perspective by discussing the role of hardware isolation and context switching in security. However, it lacks deeper critical evaluation of the approaches, such as their trade-offs or effectiveness, and stops short of forming a novel or meta-level framework."}}
